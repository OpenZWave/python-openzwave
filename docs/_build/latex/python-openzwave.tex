% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{python-openzwave Documentation}
\date{March 19, 2015}
\release{0.2.6}
\author{bibi21000}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{libopenzwave module}
\label{libopenzwave:libopenzwave-module}\label{libopenzwave::doc}\label{libopenzwave:welcome-to-python-openzwave-s-documentation}\phantomsection\label{libopenzwave:module-libopenzwave}\index{libopenzwave (module)}\phantomsection\label{libopenzwave:module-libopenzwave}\index{libopenzwave (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave C++

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{EnumWithDoc (class in libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.EnumWithDoc}\pysigline{\strong{class }\code{libopenzwave.}\bfcode{EnumWithDoc}}
Bases: \code{str}
\index{setDoc() (libopenzwave.EnumWithDoc method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.EnumWithDoc.setDoc}\pysiglinewithargsret{\bfcode{setDoc}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{PyManager (class in libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager}\pysigline{\strong{class }\code{libopenzwave.}\bfcode{PyManager}}
Bases: \code{object}

The main public interface to OpenZWave.

A singleton class providing the main public interface to OpenZWave.  The
Manager class exposes all the functionality required to add Z-Wave support to
an application.  It handles the sending and receiving of Z-Wave messages as
well as the configuration of a Z-Wave network and its devices, freeing the
library user from the burden of learning the low-level details of the Z-Wave
protocol.

All Z-Wave functionality is accessed via the Manager class.  While this does
not make for the most efficient code structure, it does enable the library to
handle potentially complex and hard-to-debug issues such as multi-threading and
object lifespans behind the scenes. Application development is therefore
simplified and less prone to bugs.

There can be only one instance of the Manager class, and all applications will
start by calling Manager::Create static method to create that instance.  From
then on, a call to the Manager::Get static method will return the pointer to
the Manager object.  On application exit, Manager::Destroy should be called to
allow OpenZWave to clean up and delete any other objects it has created.

Once the Manager has been created, a call should be made to Manager::AddWatcher
to install a notification callback handler.  This handler will receive
notifications of Z-Wave network changes and updates to device values, and is an
essential element of OpenZWave.

Next, a call should be made to Manager::AddDriver for each Z-Wave controller
attached to the PC.  Each Driver will handle the sending and receiving of
messages for all the devices in its controller's Z-Wave network.  The Driver
will read any previously saved configuration and then query the Z-Wave
controller for any missing information.  Once that process is complete, a
DriverReady notification callback will be sent containing the Home ID of the
controller, which is required by most of the other Manager class methods.

After the DriverReady notification is sent, the Driver will poll each node on
the network to update information about each node.  After all ``awake'' nodes
have been polled, an ``AllAwakeNodesQueried'' notification is sent.  This is when
a client application can expect all of the node information (both static
information, like the physical device's capabilities, session information (like
{[}associations and/or names{]} and dynamic information (like temperature or on/off
state) to be available.  Finally, after all nodes (whether setening or
sleeping) have been polled, an ``AllNodesQueried'' notification is sent.
\index{CALLBACK\_DESC (libopenzwave.PyManager attribute)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.CALLBACK_DESC}\pysigline{\bfcode{CALLBACK\_DESC}\strong{ = (`value added', `value removed', `value changed', `groups changed', `new node', `node added', `node removed', `node protocol info', `node naming', `node event', `polling disabled', `polling enabled', `driver ready', `driver reset', `message complete', `node queries complete', `awake nodes queried', `all nodes queried')}}
\end{fulllineitems}

\index{COMMAND\_CLASS\_DESC (libopenzwave.PyManager attribute)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.COMMAND_CLASS_DESC}\pysigline{\bfcode{COMMAND\_CLASS\_DESC}\strong{ = \{0: `COMMAND\_CLASS\_NO\_OPERATION', 32: `COMMAND\_CLASS\_BASIC', 33: `COMMAND\_CLASS\_CONTROLLER\_REPLICATION', 34: `COMMAND\_CLASS\_APPLICATION\_STATUS', 35: `COMMAND\_CLASS\_ZIP\_SERVICES', 36: `COMMAND\_CLASS\_ZIP\_SERVER', 37: `COMMAND\_CLASS\_SWITCH\_BINARY', 38: `COMMAND\_CLASS\_SWITCH\_MULTILEVEL', 39: `COMMAND\_CLASS\_SWITCH\_ALL', 40: `COMMAND\_CLASS\_SWITCH\_TOGGLE\_BINARY', 41: `COMMAND\_CLASS\_SWITCH\_TOGGLE\_MULTILEVEL', 42: `COMMAND\_CLASS\_CHIMNEY\_FAN', 43: `COMMAND\_CLASS\_SCENE\_ACTIVATION', 44: `COMMAND\_CLASS\_SCENE\_ACTUATOR\_CONF', 45: `COMMAND\_CLASS\_SCENE\_CONTROLLER\_CONF', 46: `COMMAND\_CLASS\_ZIP\_CLIENT', 47: `COMMAND\_CLASS\_ZIP\_ADV\_SERVICES', 48: `COMMAND\_CLASS\_SENSOR\_BINARY', 49: `COMMAND\_CLASS\_SENSOR\_MULTILEVEL', 50: `COMMAND\_CLASS\_METER', 51: `COMMAND\_CLASS\_ZIP\_ADV\_SERVER', 52: `COMMAND\_CLASS\_ZIP\_ADV\_CLIENT', 53: `COMMAND\_CLASS\_METER\_PULSE', 56: `COMMAND\_CLASS\_THERMOSTAT\_HEATING', 60: `COMMAND\_CLASS\_METER\_TBL\_CONFIG', 61: `COMMAND\_CLASS\_METER\_TBL\_MONITOR', 62: `COMMAND\_CLASS\_METER\_TBL\_PUSH', 64: `COMMAND\_CLASS\_THERMOSTAT\_MODE', 66: `COMMAND\_CLASS\_THERMOSTAT\_OPERATING\_STATE', 67: `COMMAND\_CLASS\_THERMOSTAT\_SETPOINT', 68: `COMMAND\_CLASS\_THERMOSTAT\_FAN\_MODE', 69: `COMMAND\_CLASS\_THERMOSTAT\_FAN\_STATE', 70: `COMMAND\_CLASS\_CLIMATE\_CONTROL\_SCHEDULE', 71: `COMMAND\_CLASS\_THERMOSTAT\_SETBACK', 76: `COMMAND\_CLASS\_DOOR\_LOCK\_LOGGING', 78: `COMMAND\_CLASS\_SCHEDULE\_ENTRY\_LOCK', 80: `COMMAND\_CLASS\_BASIC\_WINDOW\_COVERING', 81: `COMMAND\_CLASS\_MTP\_WINDOW\_COVERING', 96: `COMMAND\_CLASS\_MULTI\_CHANNEL\_V2', 97: `COMMAND\_CLASS\_DISPLAY', 98: `COMMAND\_CLASS\_DOOR\_LOCK', 99: `COMMAND\_CLASS\_USER\_CODE', 100: `COMMAND\_CLASS\_GARAGE\_DOOR', 112: `COMMAND\_CLASS\_CONFIGURATION', 113: `COMMAND\_CLASS\_ALARM', 114: `COMMAND\_CLASS\_MANUFACTURER\_SPECIFIC', 115: `COMMAND\_CLASS\_POWERLEVEL', 117: `COMMAND\_CLASS\_PROTECTION', 118: `COMMAND\_CLASS\_LOCK', 119: `COMMAND\_CLASS\_NODE\_NAMING', 120: `COMMAND\_CLASS\_ACTUATOR\_MULTILEVEL', 121: `COMMAND\_CLASS\_KICK', 122: `COMMAND\_CLASS\_FIRMWARE\_UPDATE\_MD', 123: `COMMAND\_CLASS\_GROUPING\_NAME', 124: `COMMAND\_CLASS\_REMOTE\_ASSOCIATION\_ACTIVATE', 125: `COMMAND\_CLASS\_REMOTE\_ASSOCIATION', 128: `COMMAND\_CLASS\_BATTERY', 129: `COMMAND\_CLASS\_CLOCK', 130: `COMMAND\_CLASS\_HAIL', 131: `COMMAND\_CLASS\_NETWORK\_STAT', 132: `COMMAND\_CLASS\_WAKE\_UP', 133: `COMMAND\_CLASS\_ASSOCIATION', 134: `COMMAND\_CLASS\_VERSION', 135: `COMMAND\_CLASS\_INDICATOR', 136: `COMMAND\_CLASS\_PROPRIETARY', 137: `COMMAND\_CLASS\_LANGUAGE', 138: `COMMAND\_CLASS\_TIME', 139: `COMMAND\_CLASS\_TIME\_PARAMETERS', 140: `COMMAND\_CLASS\_GEOGRAPHIC\_LOCATION', 141: `COMMAND\_CLASS\_COMPOSITE', 142: `COMMAND\_CLASS\_MULTI\_INSTANCE\_ASSOCIATION', 143: `COMMAND\_CLASS\_MULTI\_CMD', 144: `COMMAND\_CLASS\_ENERGY\_PRODUCTION', 145: `COMMAND\_CLASS\_MANUFACTURER\_PROPRIETARY', 146: `COMMAND\_CLASS\_SCREEN\_MD', 147: `COMMAND\_CLASS\_SCREEN\_ATTRIBUTES', 148: `COMMAND\_CLASS\_SIMPLE\_AV\_CONTROL', 149: `COMMAND\_CLASS\_AV\_CONTENT\_DIRECTORY\_MD', 150: `COMMAND\_CLASS\_AV\_RENDERER\_STATUS', 151: `COMMAND\_CLASS\_AV\_CONTENT\_SEARCH\_MD', 152: `COMMAND\_CLASS\_SECURITY', 153: `COMMAND\_CLASS\_AV\_TAGGING\_MD', 154: `COMMAND\_CLASS\_IP\_CONFIGURATION', 155: `COMMAND\_CLASS\_ASSOCIATION\_COMMAND\_CONFIGURATION', 156: `COMMAND\_CLASS\_SENSOR\_ALARM', 157: `COMMAND\_CLASS\_SILENCE\_ALARM', 158: `COMMAND\_CLASS\_SENSOR\_CONFIGURATION', 239: `COMMAND\_CLASS\_MARK', 240: `COMMAND\_CLASS\_NON\_INTEROPERABLE'\}}}
\end{fulllineitems}

\index{activateScene() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.activateScene}\pysiglinewithargsret{\bfcode{activateScene}}{}{}~\phantomsection\label{libopenzwave:activatescene}
Activate given scene to perform all its actions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{sceneId} (\emph{int}) -- The ID of the scene to activate.

\item[{Returns}] \leavevmode
True if it is successful.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}

\end{description}\end{quote}

\end{fulllineitems}

\index{addAssociation() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.addAssociation}\pysiglinewithargsret{\bfcode{addAssociation}}{}{}~\phantomsection\label{libopenzwave:addassociation}
Adds a node to an association group.

Due to the possibility of a device being asleep, the command is assumed to
suceeed, and the association data held in this class is updated directly.  This
will be reverted by a future Association message from the device if the Z-Wave
message actually failed to get through.  Notification callbacks will be sent in
both cases.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node whose associations are to be changed.

\item {} 
\textbf{groupIdx} (\emph{int}) -- One-based index of the group (because Z-Wave product manuals use one-based group numbering).

\item {} 
\textbf{targetNodeId} (\emph{int}) -- Identifier for the node that will be added to the association group.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumgroups]{getNumGroups}}, {\hyperref[libopenzwave:getassociations]{getAssociations}}, {\hyperref[libopenzwave:getmaxassociations]{getMaxAssociations}}, {\hyperref[libopenzwave:removeassociation]{removeAssociation}}

\end{description}\end{quote}

\end{fulllineitems}

\index{addDriver() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.addDriver}\pysiglinewithargsret{\bfcode{addDriver}}{}{}~\phantomsection\label{libopenzwave:adddriver}
Creates a new driver for a Z-Wave controller.

This method creates a Driver object for handling communications with a single
Z-Wave controller.  In the background, the driver first tries to read
configuration data saved during a previous run.  It then queries the controller
directly for any missing information, and a refresh of the set of nodes that
it controls.  Once this information has been received, a DriverReady
notification callback is sent, containing the Home ID of the controller.  This
Home ID is required by most of the OpenZWave Manager class methods.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{serialport} (\emph{str}) -- The string used to open the controller.  On Windows this might be something like ''.COM3'', or on Linux ``/dev/ttyUSB0''.

\item[{Returns}] \leavevmode
True if a new driver was created

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:removedriver]{removeDriver}}

\end{description}\end{quote}

\end{fulllineitems}

\index{addSceneValue() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.addSceneValue}\pysiglinewithargsret{\bfcode{addSceneValue}}{}{}~\phantomsection\label{libopenzwave:addscenevalue}
Add a ValueID of value to an existing scene.

Actually I don't know how to use it :)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sceneid} (\emph{int}) -- The ID of a scene.

\item {} 
\textbf{id} (\emph{int}) -- The ID of a value.

\item {} 
\textbf{value} (\emph{bool, int, float, string}) -- The value to set

\end{itemize}

\item[{Returns}] \leavevmode
An integer representing the result of the operation
0 : The C method fails
1 : The C method succeed
2 : Can't find id in the map

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}

\end{description}\end{quote}

\end{fulllineitems}

\index{addWatcher() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.addWatcher}\pysiglinewithargsret{\bfcode{addWatcher}}{}{}~\phantomsection\label{libopenzwave:addwatcher}
Add a notification watcher.

In OpenZWave, all feedback from the Z-Wave network is sent to the application
via callbacks.  This method allows the application to add a notification
callback handler, known as a ``watcher'' to OpenZWave.  An application needs only
add a single watcher - all notifications will be reported to it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{pythonfunc} (\emph{callback}) -- Watcher pointer to a function that will be called by the notification system.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:removewatcher]{removeWatcher}}

\end{description}\end{quote}

\end{fulllineitems}

\index{beginControllerCommand() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.beginControllerCommand}\pysiglinewithargsret{\bfcode{beginControllerCommand}}{}{}~\phantomsection\label{libopenzwave:begincontrollercommand}
Start a controller command process.

Commands :
\begin{quote}
\begin{itemize}
\item {} 
Driver::ControllerCommand\_AddDevice - Add a new device or controller to the Z-Wave network.

\item {} 
Driver::ControllerCommand\_CreateNewPrimary - Create a new primary controller when old primary fails. Requires SUC.

\item {} 
Driver::ControllerCommand\_ReceiveConfiguration - Receive network configuration information from primary controller. Requires secondary.

\item {} 
Driver::ControllerCommand\_RemoveDevice - Remove a device or controller from the Z-Wave network.

\item {} 
Driver::ControllerCommand\_RemoveFailedNode - Remove a node from the network. The node must not be responding

\end{itemize}

and be on the controller's failed node list.
- Driver::ControllerCommand\_HasNodeFailed - Check whether a node is in the controller's failed nodes list.
- Driver::ControllerCommand\_ReplaceFailedNode - Replace a failed device with another. If the node is not in
the controller's failed nodes list, or the node responds, this command will fail.
- Driver:: ControllerCommand\_TransferPrimaryRole - Add a new controller to the network and
make it the primary.  The existing primary will become a secondary controller.
- Driver::ControllerCommand\_RequestNetworkUpdate - Update the controller with network information from the SUC/SIS.
- Driver::ControllerCommand\_RequestNodeNeighborUpdate - Get a node to rebuild its neighbour list.  This method also does RequestNodeNeighbors afterwards.
- Driver::ControllerCommand\_AssignReturnRoute - Assign a network return route to a device.
- Driver::ControllerCommand\_DeleteAllReturnRoutes - Delete all network return routes from a device.
- Driver::ControllerCommand\_SendNodeInformation - Send a node information frame.
- Driver::ControllerCommand\_ReplicationSend - Send information from primary to secondary
- Driver::ControllerCommand\_CreateButton - Create a handheld button id.
- Driver::ControllerCommand\_DeleteButton - Delete a handheld button id.
\end{quote}

Callbacks :
\begin{itemize}
\item {} 
Driver::ControllerState\_Waiting, the controller is waiting for a user action.  A notice should be displayed to the user at this point, telling them what to do next. For the add, remove, replace and transfer primary role commands, the user needs to be told to press the inclusion button on the device that  is going to be added or removed.  For ControllerCommand\_ReceiveConfiguration, they must set their other controller to send its data, and for ControllerCommand\_CreateNewPrimary, set the other controller to learn new data.

\item {} 
Driver::ControllerState\_InProgress - the controller is in the process of adding or removing the chosen node.  It is now too late to cancel the command.

\item {} 
Driver::ControllerState\_Complete - the controller has finished adding or removing the node, and the command is complete.

\item {} 
Driver::ControllerState\_Failed - will be sent if the command fails for any reason.

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item {} 
\textbf{command} (\emph{ControllerCommand}) -- The command to be sent to the controller.

\item {} 
\textbf{callback} (\emph{pfnControllerCallback\_t}) -- Pointer to a function that will be called at various stages during the command process to notify the user of progress or to request actions on the user's part.  Defaults to NULL.

\item {} 
\textbf{context} -- Pointer to user defined data that will be passed into to the callback function.  Defaults to NULL.

\item {} 
\textbf{highPower} (\emph{bool}) -- Used only with the AddDevice, AddController, RemoveDevice and RemoveController commands. Usually when adding or removing devices, the controller operates at low power so that the controller must be physically close to the device for security reasons.  If \_highPower is true, the controller will operate at normal power levels instead.  Defaults to false.

\item {} 
\textbf{nodeId} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item {} 
\textbf{arg} (\emph{int}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:cancelcontrollercommand]{cancelControllerCommand}}

\end{description}\end{quote}

\end{fulllineitems}

\index{cancelControllerCommand() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.cancelControllerCommand}\pysiglinewithargsret{\bfcode{cancelControllerCommand}}{}{}~\phantomsection\label{libopenzwave:cancelcontrollercommand}
Cancels any in-progress command running on a controller.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
True if a command was running and was cancelled.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:begincontrollercommand]{beginControllerCommand}}

\end{description}\end{quote}

\end{fulllineitems}

\index{clearSwitchPoints() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.clearSwitchPoints}\pysiglinewithargsret{\bfcode{clearSwitchPoints}}{}{}~\phantomsection\label{libopenzwave:clearswitchpoints}
Clears all switch points from the schedule
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The unique identifier of the schedule value.

\item[{Returns}] \leavevmode
True if all switch points are clear.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setswitchpoint]{setSwitchPoint}}, {\hyperref[libopenzwave:removeswitchpoint]{removeSwitchPoint}}, {\hyperref[libopenzwave:getswitchpoint]{getSwitchPoint}}, {\hyperref[libopenzwave:getnumswitchpoints]{getNumSwitchPoints}}

\end{description}\end{quote}

\end{fulllineitems}

\index{create() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.create}\pysiglinewithargsret{\bfcode{create}}{}{}~\phantomsection\label{libopenzwave:create}
Creates the Manager singleton object.

The Manager provides the public interface to OpenZWave, exposing all the
functionality required to add Z-Wave support to an application. There can be
only one Manager in an OpenZWave application.  An Options object must be
created and Locked first, otherwise the call to Manager::Create will fail.
Once the Manager has been created, call AddWatcher to install a notification
callback handler, and then call the AddDriver method for each attached PC
Z-Wave controller in turn.

\end{fulllineitems}

\index{createScene() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.createScene}\pysiglinewithargsret{\bfcode{createScene}}{}{}~\phantomsection\label{libopenzwave:createscene}
Create a Scene.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Scene ID used to reference the scene. 0 is failure result.

\item[{Return type}] \leavevmode
id

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}

\end{description}\end{quote}

\end{fulllineitems}

\index{disablePoll() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.disablePoll}\pysiglinewithargsret{\bfcode{disablePoll}}{}{}~\phantomsection\label{libopenzwave:disablepoll}
Disable polling of a value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of the value to disable polling.

\item[{Returns}] \leavevmode
True if polling was disabled.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getpollinterval]{getPollInterval}}, {\hyperref[libopenzwave:setpollinterval]{setPollInterval}}, {\hyperref[libopenzwave:enablepoll]{enablePoll}}, {\hyperref[libopenzwave:ispolled]{isPolled}}, {\hyperref[libopenzwave:setpollintensity]{setPollIntensity}}, {\hyperref[libopenzwave:getpollintensity]{getPollIntensity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{enablePoll() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.enablePoll}\pysiglinewithargsret{\bfcode{enablePoll}}{}{}~\phantomsection\label{libopenzwave:enablepoll}
Enable the polling of a device's state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The ID of the value to start polling

\item {} 
\textbf{intensity} (\emph{int}) -- The intensity of the poll

\end{itemize}

\item[{Returns}] \leavevmode
True if polling was enabled.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getpollinterval]{getPollInterval}}, {\hyperref[libopenzwave:setpollinterval]{setPollInterval}}, {\hyperref[libopenzwave:ispolled]{isPolled}}, {\hyperref[libopenzwave:setpollintensity]{setPollIntensity}}, {\hyperref[libopenzwave:disablepoll]{disablePoll}}, {\hyperref[libopenzwave:getpollintensity]{getPollIntensity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getAllScenes() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getAllScenes}\pysiglinewithargsret{\bfcode{getAllScenes}}{}{}~\phantomsection\label{libopenzwave:getallscenes}
Gets a set of all the SceneIds
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A set() containing neighboring scene IDs

\item[{Return type}] \leavevmode
set()

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getAssociations() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getAssociations}\pysiglinewithargsret{\bfcode{getAssociations}}{}{}~\phantomsection\label{libopenzwave:getassociations}
Gets the associations for a group
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node whose associations we are interested in.

\item {} 
\textbf{groupIdx} (\emph{int}) -- one-based index of the group (because Z-Wave product manuals use one-based group numbering).

\end{itemize}

\item[{Returns}] \leavevmode
A set containing IDs of members of the group

\item[{Return type}] \leavevmode
set()

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumgroups]{getNumGroups}}, {\hyperref[libopenzwave:addassociation]{addAssociation}}, {\hyperref[libopenzwave:removeassociation]{removeAssociation}}, {\hyperref[libopenzwave:getmaxassociations]{getMaxAssociations}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getChangeVerified() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getChangeVerified}\pysiglinewithargsret{\bfcode{getChangeVerified}}{}{}~
If so, the library will immediately refresh the value a second time whenever a change is observed.
This helps to filter out spurious data reported occasionally by some devices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The unique identifier of the value whose changes should or should not be verified.

\item[{Returns}] \leavevmode
True if is verified.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{getControllerInterfaceType() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getControllerInterfaceType}\pysiglinewithargsret{\bfcode{getControllerInterfaceType}}{}{}
..\_getControllerInterfaceType:
Retrieve controller interface type, Unknown, Serial, Hid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
The controller interface type

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getControllerNodeId() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getControllerNodeId}\pysiglinewithargsret{\bfcode{getControllerNodeId}}{}{}~\phantomsection\label{libopenzwave:getcontrollernodeid}
Get the node ID of the Z-Wave controller.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
The node ID of the Z-Wave controller

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getControllerPath() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getControllerPath}\pysiglinewithargsret{\bfcode{getControllerPath}}{}{}
..\_getControllerPath:
Retrieve controller interface path, name or path used to open the controller hardware
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
The controller interface type

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getDriverStatistics() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getDriverStatistics}\pysiglinewithargsret{\bfcode{getDriverStatistics}}{}{}~\phantomsection\label{libopenzwave:getdriverstatistics}
Retrieve statistics from driver.

Statistics:
\begin{itemize}
\item {} 
SOFCnt : Number of SOF bytes received

\item {} 
ACKWaiting : Number of unsolicited messages while waiting for an ACK

\item {} 
readAborts : Number of times read were aborted due to timeouts

\item {} 
badChecksum : Number of bad checksums

\item {} 
readCnt : Number of messages successfully read

\item {} 
writeCnt : Number of messages successfully sent

\item {} 
CANCnt : Number of CAN bytes received

\item {} 
NAKCnt : Number of NAK bytes received

\item {} 
ACKCnt : Number of ACK bytes received

\item {} 
OOFCnt : Number of bytes out of framing

\item {} 
dropped : Number of messages dropped \& not delivered

\item {} 
retries : Number of messages retransmitted

\item {} 
callbacks : Number of unexpected callbacks

\item {} 
badroutes : Number of failed messages due to bad route response

\item {} 
noack : Number of no ACK returned errors

\item {} 
netbusy : Number of network busy/failure messages

\item {} 
nondelivery : Number of messages not delivered to network

\item {} 
routedbusy : Number of messages received with routed busy status

\item {} 
broadcastReadCnt : Number of broadcasts read

\item {} 
broadcastWriteCnt : Number of broadcasts sent

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item {} 
\textbf{data} (\emph{int}) -- Pointer to structure DriverData to return values

\end{itemize}

\item[{Returns}] \leavevmode
A dict containing statistics of the driver.

\item[{Return type}] \leavevmode
dict()

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodestatistics]{getNodeStatistics}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getGroupLabel() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getGroupLabel}\pysiglinewithargsret{\bfcode{getGroupLabel}}{}{}
Returns a label for the particular group of a node.
\phantomsection\label{libopenzwave:getgrouplabel}
This label is populated by the device specific configuration files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeid} (\emph{int}) -- The ID of the node whose associations are to be changed.

\item {} 
\textbf{groupidx} (\emph{int}) -- One-based index of the group (because Z-Wave product manuals use one-based group numbering).

\end{itemize}

\item[{Returns}] \leavevmode
The label for the particular group of a node.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumgroups]{getNumGroups}}, {\hyperref[libopenzwave:getassociations]{getAssociations}}, {\hyperref[libopenzwave:getmaxassociations]{getMaxAssociations}}, {\hyperref[libopenzwave:addassociation]{addAssociation}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getLibraryTypeName() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getLibraryTypeName}\pysiglinewithargsret{\bfcode{getLibraryTypeName}}{}{}~\phantomsection\label{libopenzwave:getlibrarytypename}
Get a string containing the Z-Wave API library type used by a controller.

The possible library types are:
\begin{itemize}
\item {} 
Static Controller

\item {} 
Controller

\item {} 
Enhanced Slave

\item {} 
Slave

\item {} 
Installer

\item {} 
Routing Slave

\item {} 
Bridge Controller

\item {} 
Device Under Test

\end{itemize}

The controller should never return a slave library type.  For a more efficient
test of whether a controller is a Bridge Controller, use the IsBridgeController
method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
A string containing the library type.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getlibraryversion]{getLibraryVersion}}, {\hyperref[libopenzwave:getpythonlibraryversion]{getPythonLibraryVersion}}, {\hyperref[libopenzwave:getozwlibraryversion]{getOzwLibraryVersion}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getLibraryVersion() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getLibraryVersion}\pysiglinewithargsret{\bfcode{getLibraryVersion}}{}{}~\phantomsection\label{libopenzwave:getlibraryversion}
Get the version of the Z-Wave API library used by a controller.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
A string containing the library version. For example, ``Z-Wave 2.48''.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getpythonlibraryversion]{getPythonLibraryVersion}}, {\hyperref[libopenzwave:getlibrarytypename]{getLibraryTypeName}}, {\hyperref[libopenzwave:getozwlibraryversion]{getOzwLibraryVersion}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getMaxAssociations() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getMaxAssociations}\pysiglinewithargsret{\bfcode{getMaxAssociations}}{}{}~\phantomsection\label{libopenzwave:getmaxassociations}
Gets the maximum number of associations for a group.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeid} (\emph{int}) -- The ID of the node whose associations we are interested in.

\item {} 
\textbf{groupidx} (\emph{int}) -- One-based index of the group (because Z-Wave product manuals use one-based group numbering).

\end{itemize}

\item[{Returns}] \leavevmode
The maximum number of nodes that can be associated into the group.

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumgroups]{getNumGroups}}, {\hyperref[libopenzwave:addassociation]{addAssociation}}, {\hyperref[libopenzwave:removeassociation]{removeAssociation}}, {\hyperref[libopenzwave:getassociations]{getAssociations}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeBasic() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeBasic}\pysiglinewithargsret{\bfcode{getNodeBasic}}{}{}~\phantomsection\label{libopenzwave:getnodebasic}
Get the basic type of a node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
The node basic type.

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodetype]{getNodeType}}, {\hyperref[libopenzwave:getnodespecific]{getNodeSpecific}}, {\hyperref[libopenzwave:getnodegeneric]{getNodeGeneric}}, {\hyperref[libopenzwave:getnodesecurity]{getNodeSecurity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeClassInformation() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeClassInformation}\pysiglinewithargsret{\bfcode{getNodeClassInformation}}{}{}~\phantomsection\label{libopenzwave:getnodeclassinformation}
Helper method to return whether a particular class is available in a node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\item {} 
\textbf{commandClassId} (\emph{int}) -- control class to query

\item {} 
\textbf{className} (\emph{str}) -- (optional, default=None) specific name of class to query

\item {} 
\textbf{classVersion} (\emph{int}) -- (optional, default=None) specific class version

\end{itemize}

\item[{Returns}] \leavevmode
True if the node does have the class instantiated, will return name \& version

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeGeneric() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeGeneric}\pysiglinewithargsret{\bfcode{getNodeGeneric}}{}{}~\phantomsection\label{libopenzwave:getnodegeneric}
Get the generic type of a node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
The node generic type.

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodetype]{getNodeType}}, {\hyperref[libopenzwave:getnodespecific]{getNodeSpecific}}, {\hyperref[libopenzwave:getnodebasic]{getNodeBasic}}, {\hyperref[libopenzwave:getnodesecurity]{getNodeSecurity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeLocation() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeLocation}\pysiglinewithargsret{\bfcode{getNodeLocation}}{}{}~\phantomsection\label{libopenzwave:getnodelocation}
Get the location of a node

The node location is a user-editable string that would normally be handled by
the Node Naming commmand class, but many devices do not support it.  So that a
node can always report its location, OpenZWave stores it with the node data,
and provides access through this method and SetNodeLocation, rather than
reporting it via a command class Value object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
str -- A string containing the nodes location.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setnodelocation]{setNodeLocation}}, {\hyperref[libopenzwave:getnodename]{getNodeName}}, {\hyperref[libopenzwave:setnodename]{setNodeName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeManufacturerId() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeManufacturerId}\pysiglinewithargsret{\bfcode{getNodeManufacturerId}}{}{}~\phantomsection\label{libopenzwave:getnodemanufacturerid}
Get the manufacturer ID of a device

The manufacturer ID is a four digit hex code and would normally be handled by
the Manufacturer-Specific commmand class, but not all devices support it.
Although the value reported by this method will be an empty string if the
command class is not supported and cannot be set by the user, the manufacturer
ID is still stored with the node data (rather than being reported via a command
class Value object) to retain a consistent approach with the other manufacturer
specific data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
A string containing the nodes manufacturer ID, or an empty string if the manufactuer-specific command class is not supported by the device.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodeproducttype]{getNodeProductType}}, {\hyperref[libopenzwave:getnodeproductid]{getNodeProductId}}, {\hyperref[libopenzwave:getnodemanufacturername]{getNodeManufacturerName}}, {\hyperref[libopenzwave:setnodemanufacturername]{setNodeManufacturerName}},     {\hyperref[libopenzwave:getnodeproductname]{getNodeProductName}}, {\hyperref[libopenzwave:setnodeproductname]{setNodeProductName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeManufacturerName() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeManufacturerName}\pysiglinewithargsret{\bfcode{getNodeManufacturerName}}{}{}~\begin{quote}
\phantomsection\label{libopenzwave:getnodemanufacturername}\end{quote}

Get the manufacturer name of a device

The manufacturer name would normally be handled by the Manufacturer Specific
commmand class, taking the manufacturer ID reported by the device and using it
to look up the name from the manufacturer\_specific.xml file in the OpenZWave
config folder.  However, there are some devices that do not support the command
class, so to enable the user to manually set the name, it is stored with the
node data and accessed via this method rather than being reported via a command
class Value object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
A string containing the nodes manufacturer name.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setnodemanufacturername]{setNodeManufacturerName}}, {\hyperref[libopenzwave:getnodeproductname]{getNodeProductName}}, {\hyperref[libopenzwave:setnodeproductname]{setNodeProductName}},     {\hyperref[libopenzwave:getnodemanufacturerid]{getNodeManufacturerId}}, {\hyperref[libopenzwave:getnodeproductid]{getNodeProductId}}, {\hyperref[libopenzwave:getnodeproducttype]{getNodeProductType}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeMaxBaudRate() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeMaxBaudRate}\pysiglinewithargsret{\bfcode{getNodeMaxBaudRate}}{}{}~\phantomsection\label{libopenzwave:getnodemaxbaudrate}
Get the maximum baud rate of a nodes communications
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
The baud rate in bits per second.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeName() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeName}\pysiglinewithargsret{\bfcode{getNodeName}}{}{}~\phantomsection\label{libopenzwave:getnodename}
Get the name of a node

The node name is a user-editable label for the node that would normally be
handled by the Node Naming commmand class, but many devices do not support it.
So that a node can always be named, OpenZWave stores it with the node data, and
provides access through this method and SetNodeName, rather than reporting it
via a command class Value object.  The maximum length of a node name is 16
characters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
str -- A string containing the node name.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setnodename]{setNodeName}}, {\hyperref[libopenzwave:getnodelocation]{getNodeLocation}}, {\hyperref[libopenzwave:setnodelocation]{setNodeLocation}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeNeighbors() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeNeighbors}\pysiglinewithargsret{\bfcode{getNodeNeighbors}}{}{}~\phantomsection\label{libopenzwave:getnodeneighbors}
Get the bitmap of this node's neighbors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
A set containing neighboring node IDs

\item[{Return type}] \leavevmode
set()

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeProductId() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeProductId}\pysiglinewithargsret{\bfcode{getNodeProductId}}{}{}~\phantomsection\label{libopenzwave:getnodeproductid}
Get the product ID of a device

The product ID is a four digit hex code and would normally be handled by the
Manufacturer-Specific commmand class, but not all devices support it.  Although
the value reported by this method will be an empty string if the command class
is not supported and cannot be set by the user, the product ID is still stored
with the node data (rather than being reported via a command class Value
object)  to retain a consistent approach with the other manufacturer specific
data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
A string containing the nodes product ID, or an empty string if the manufactuer-specific command class is not supported by the device.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodemanufacturerid]{getNodeManufacturerId}}, {\hyperref[libopenzwave:getnodeproducttype]{getNodeProductType}}, {\hyperref[libopenzwave:getnodemanufacturername]{getNodeManufacturerName}}, {\hyperref[libopenzwave:setnodemanufacturername]{setNodeManufacturerName}}, {\hyperref[libopenzwave:getnodeproductname]{getNodeProductName}}, {\hyperref[libopenzwave:setnodeproductname]{setNodeProductName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeProductName() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeProductName}\pysiglinewithargsret{\bfcode{getNodeProductName}}{}{}~\phantomsection\label{libopenzwave:getnodeproductname}
Get the product name of a device

The product name would normally be handled by the Manufacturer Specific
commmand class, taking the product Type and ID reported by the device and using
it to look up the name from the manufacturer\_specific.xml file in the OpenZWave
config folder.  However, there are some devices that do not support the command
class, so to enable the user to manually set the name, it is stored with the
node data and accessed via this method rather than being reported via a command
class Value object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
str -- A string containing the nodes product name.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setnodeproductname]{setNodeProductName}}, {\hyperref[libopenzwave:getnodemanufacturername]{getNodeManufacturerName}}, {\hyperref[libopenzwave:setnodemanufacturername]{setNodeManufacturerName}},     {\hyperref[libopenzwave:getnodemanufacturerid]{getNodeManufacturerId}}, {\hyperref[libopenzwave:getnodeproductid]{getNodeProductId}}, {\hyperref[libopenzwave:getnodeproducttype]{getNodeProductType}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeProductType() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeProductType}\pysiglinewithargsret{\bfcode{getNodeProductType}}{}{}~\phantomsection\label{libopenzwave:getnodeproducttype}
Get the product type of a device

The product type is a four digit hex code and would normally be handled by the
Manufacturer Specific commmand class, but not all devices support it.  Although
the value reported by this method will be an empty string if the command class
is not supported and cannot be set by the user, the product type is still
stored with the node data (rather than being reported via a command class Value
object) to retain a consistent approach with the other manufacturer specific
data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
A string containing the nodes product type, or an empty string if the manufactuer-specific command class is not supported by the device.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodemanufacturerid]{getNodeManufacturerId}}, {\hyperref[libopenzwave:getnodeproductid]{getNodeProductId}}, {\hyperref[libopenzwave:getnodemanufacturername]{getNodeManufacturerName}}, {\hyperref[libopenzwave:setnodemanufacturername]{setNodeManufacturerName}},     {\hyperref[libopenzwave:getnodeproductname]{getNodeProductName}}, {\hyperref[libopenzwave:setnodeproductname]{setNodeProductName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeQueryStage() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeQueryStage}\pysiglinewithargsret{\bfcode{getNodeQueryStage}}{}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
name of current query stage as a string.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeQueryStageCode() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeQueryStageCode}\pysiglinewithargsret{\bfcode{getNodeQueryStageCode}}{}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{queryStage} (\emph{str}) -- The query stage description.

\item[{Returns}] \leavevmode
code value.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeSecurity() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeSecurity}\pysiglinewithargsret{\bfcode{getNodeSecurity}}{}{}~\phantomsection\label{libopenzwave:getnodesecurity}
Get the security byte for a node.  Bit meanings are still to be determined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
The node security byte

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodetype]{getNodeType}}, {\hyperref[libopenzwave:getnodespecific]{getNodeSpecific}}, {\hyperref[libopenzwave:getnodegeneric]{getNodeGeneric}}, {\hyperref[libopenzwave:getnodebasic]{getNodeBasic}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeSpecific() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeSpecific}\pysiglinewithargsret{\bfcode{getNodeSpecific}}{}{}~\phantomsection\label{libopenzwave:getnodespecific}
Get the specific type of a node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
int -- The node specific type.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodetype]{getNodeType}}, {\hyperref[libopenzwave:getnodegeneric]{getNodeGeneric}}, {\hyperref[libopenzwave:getnodebasic]{getNodeBasic}}, {\hyperref[libopenzwave:getnodesecurity]{getNodeSecurity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeStatistics() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeStatistics}\pysiglinewithargsret{\bfcode{getNodeStatistics}}{}{}~\phantomsection\label{libopenzwave:getnodestatistics}
Retrieve statistics per node

Statistics:
\begin{quote}
\begin{description}
\item[{cdef struct NodeData:}] \leavevmode\begin{itemize}
\item {} 
sentCnt                              \# Number of messages sent from this node.

\item {} 
sentFailed                           \# Number of sent messages failed

\item {} 
retries                                \# Number of message retries

\item {} 
receivedCnt                        \# Number of messages received from this node.

\item {} 
receivedDups                      \# Number of duplicated messages received;

\item {} 
receivedUnsolicited             \# Number of messages received unsolicited

\item {} 
sentTS                                \# Last message sent time

\item {} 
receivedTS                          \# Last message received time

\item {} 
lastRequestRTT                    \# Last message request RTT

\item {} 
averageRequestRTT             \# Average Request Round Trip Time (ms).

\item {} 
lastResponseRTT                  \# Last message response RTT

\item {} 
averageResponseRTT           \#Average Reponse round trip time.

\item {} 
quality                                \# Node quality measure

\item {} 
lastReceivedMessage{[}254{]}   \# Place to hold last received message

\item {} \begin{description}
\item[{ccData                                \# List of statistic}] \leavevmode\begin{itemize}
\item {} 
commandClassId               \# Num of commandClass id.

\item {} 
sentCnt                             \# Number of messages sent from this CommandClass.

\item {} 
receivedCnt                       \# Number of messages received from this CommandClass.

\end{itemize}

\end{description}

\end{itemize}

\end{description}
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\item {} 
\textbf{data} (\emph{int}) -- Pointer to structure NodeData to return values

\end{itemize}

\item[{Returns}] \leavevmode
A dict containing statistics of the node.

\item[{Return type}] \leavevmode
dict()

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getdriverstatistics]{getDriverStatistics}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeType() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeType}\pysiglinewithargsret{\bfcode{getNodeType}}{}{}~\phantomsection\label{libopenzwave:getnodetype}
Get a human-readable label describing the node

The label is taken from the Z-Wave specific, generic or basic type, depending
on which of those values are specified by the node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
A string containing the label text.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodespecific]{getNodeSpecific}}, {\hyperref[libopenzwave:getnodegeneric]{getNodeGeneric}}, {\hyperref[libopenzwave:getnodebasic]{getNodeBasic}}, {\hyperref[libopenzwave:getnodesecurity]{getNodeSecurity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeVersion() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNodeVersion}\pysiglinewithargsret{\bfcode{getNodeVersion}}{}{}~\phantomsection\label{libopenzwave:getnodeversion}
Get the version number of a node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
The node version number

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getNumGroups() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNumGroups}\pysiglinewithargsret{\bfcode{getNumGroups}}{}{}~\phantomsection\label{libopenzwave:getnumgroups}
Gets the number of association groups reported by this node

In Z-Wave, groups are numbered starting from one.  For example, if a call to
GetNumGroups returns 4, the \_groupIdx value to use in calls to GetAssociations
AddAssociation and RemoveAssociation will be a number between 1 and 4.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node whose groups we are interested in.

\end{itemize}

\item[{Returns}] \leavevmode
The number of groups.

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getassociations]{getAssociations}}, {\hyperref[libopenzwave:getmaxassociations]{getMaxAssociations}}, {\hyperref[libopenzwave:addassociation]{addAssociation}}, {\hyperref[libopenzwave:removeassociation]{removeAssociation}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNumScenes() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNumScenes}\pysiglinewithargsret{\bfcode{getNumScenes}}{}{}~\phantomsection\label{libopenzwave:getnumscenes}
Gets the number of scenes that have been defined
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The number of scenes.

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNumSwitchPoints() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getNumSwitchPoints}\pysiglinewithargsret{\bfcode{getNumSwitchPoints}}{}{}~\phantomsection\label{libopenzwave:getnumswitchpoints}
Get the number of switch points defined in a schedule
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The unique identifier of the schedule value.

\item[{Returns}] \leavevmode
The number of switch points defined in this schedule.  Returns zero if the value is not a ValueID::ValueType\_Schedule. The type can be tested with a call to ValueID::GetType.

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setswitchpoint]{setSwitchPoint}}, {\hyperref[libopenzwave:removeswitchpoint]{removeSwitchPoint}}, {\hyperref[libopenzwave:clearswitchpoints]{clearSwitchPoints}}, {\hyperref[libopenzwave:getswitchpoint]{getSwitchPoint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getOzwLibraryVersion() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getOzwLibraryVersion}\pysiglinewithargsret{\bfcode{getOzwLibraryVersion}}{}{}~\phantomsection\label{libopenzwave:getozwlibraryversion}
Get a string containing the openzwave library version.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A string containing the library type.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getlibraryversion]{getLibraryVersion}}, {\hyperref[libopenzwave:getpythonlibraryversion]{getPythonLibraryVersion}}, {\hyperref[libopenzwave:getlibrarytypename]{getLibraryTypeName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getOzwLibraryVersionNumber() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getOzwLibraryVersionNumber}\pysiglinewithargsret{\bfcode{getOzwLibraryVersionNumber}}{}{}
\_getOzwLibraryVersionNumber: Get the openzwave library version number.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A string containing the library type.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getlibraryversion]{getLibraryVersion}}, {\hyperref[libopenzwave:getpythonlibraryversion]{getPythonLibraryVersion}}, {\hyperref[libopenzwave:getlibrarytypename]{getLibraryTypeName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getPollIntensity() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getPollIntensity}\pysiglinewithargsret{\bfcode{getPollIntensity}}{}{}~\phantomsection\label{libopenzwave:getpollintensity}
Get the intensity with which this value is polled (0=none, 1=every time through the list, 2-every other time, etc).
:param id: The ID of a value.
:type id: int
:return: A integer containing the poll intensity
:rtype: int
:see: {\hyperref[libopenzwave:getpollinterval]{getPollInterval}}, {\hyperref[libopenzwave:setpollinterval]{setPollInterval}}, {\hyperref[libopenzwave:enablepoll]{enablePoll}}, {\hyperref[libopenzwave:setpollintensity]{setPollIntensity}}, {\hyperref[libopenzwave:disablepoll]{disablePoll}}, {\hyperref[libopenzwave:ispolled]{isPolled}}

\end{fulllineitems}

\index{getPollInterval() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getPollInterval}\pysiglinewithargsret{\bfcode{getPollInterval}}{}{}~\phantomsection\label{libopenzwave:getpollinterval}
Get the time period between polls of a nodes state
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The number of milliseconds between polls

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setpollinterval]{setPollInterval}}, {\hyperref[libopenzwave:enablepoll]{enablePoll}}, {\hyperref[libopenzwave:ispolled]{isPolled}}, {\hyperref[libopenzwave:setpollintensity]{setPollIntensity}}, {\hyperref[libopenzwave:disablepoll]{disablePoll}}, {\hyperref[libopenzwave:getpollintensity]{getPollIntensity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getPythonLibraryVersion() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getPythonLibraryVersion}\pysiglinewithargsret{\bfcode{getPythonLibraryVersion}}{}{}~\phantomsection\label{libopenzwave:getpythonlibraryversion}
Get the version of the python library.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A string containing the python library version. For example, ``python-openzwave version 0.1''.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getlibrarytypename]{getLibraryTypeName}}, {\hyperref[libopenzwave:getlibraryversion]{getLibraryVersion}}, {\hyperref[libopenzwave:getozwlibraryversion]{getOzwLibraryVersion}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getPythonLibraryVersionNumber() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getPythonLibraryVersionNumber}\pysiglinewithargsret{\bfcode{getPythonLibraryVersionNumber}}{}{}~\phantomsection\label{libopenzwave:getpythonlibraryversionnumber}
Get the python library version number
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A string containing the python library version. For example, ``0.1''.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getlibrarytypename]{getLibraryTypeName}}, {\hyperref[libopenzwave:getlibraryversion]{getLibraryVersion}}, {\hyperref[libopenzwave:getozwlibraryversion]{getOzwLibraryVersion}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getSUCNodeId() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getSUCNodeId}\pysiglinewithargsret{\bfcode{getSUCNodeId}}{}{}~\phantomsection\label{libopenzwave:getsucnodeid}
Get the node ID of the Static Update Controller.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
the node ID of the Z-Wave controller.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getSceneLabel() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getSceneLabel}\pysiglinewithargsret{\bfcode{getSceneLabel}}{}{}~\phantomsection\label{libopenzwave:getscenelabel}
Returns a label for the particular scene.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sceneId} (\emph{int}) -- The ID of a scene.

\item {} 
\textbf{value} (\emph{int}) -- The value to set

\end{itemize}

\item[{Returns}] \leavevmode
The label string.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getSendQueueCount() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getSendQueueCount}\pysiglinewithargsret{\bfcode{getSendQueueCount}}{}{}~\phantomsection\label{libopenzwave:getsendqueuecount}
Get count of messages in the outgoing send queue.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
Message count

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getSwitchPoint() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getSwitchPoint}\pysiglinewithargsret{\bfcode{getSwitchPoint}}{}{}~\phantomsection\label{libopenzwave:getswitchpoint}
Gets switch point data from the schedule
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The unique identifier of the schedule value.

\item {} 
\textbf{idx} (\emph{int}) -- The index of the switch point, between zero and one less than the value returned by GetNumSwitchPoints.

\item {} 
\textbf{hours} (\emph{int}) -- An integer that will be filled with the hours part of the switch point data.

\item {} 
\textbf{minutes} (\emph{int}) -- An integer that will be filled with the minutes part of the switch point data.

\item {} 
\textbf{setback} (\emph{int}) -- An integer that will be filled with the setback value.  This can range from -128 (-12.8C)to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and 122 is used to set Energy Saving mode.

\end{itemize}

\item[{Returns}] \leavevmode
True if successful.  Returns False if the value is not a ValueID::ValueType\_Schedule. The type can be tested with a call to ValueID::GetType.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setswitchpoint]{setSwitchPoint}}, {\hyperref[libopenzwave:removeswitchpoint]{removeSwitchPoint}}, {\hyperref[libopenzwave:clearswitchpoints]{clearSwitchPoints}}, {\hyperref[libopenzwave:getnumswitchpoints]{getNumSwitchPoints}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValue() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValue}\pysiglinewithargsret{\bfcode{getValue}}{}{}~\phantomsection\label{libopenzwave:getvalue}
Gets a value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The ID of a value.

\item {} 
\textbf{value} (\emph{int}) -- The value to set.

\end{itemize}

\item[{Returns}] \leavevmode
Depending of the type of the valueId, None otherwise

\item[{Return type}] \leavevmode
variable

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}, {\hyperref[libopenzwave:getvaluecommandclass]{getValueCommandClass}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueAsBool() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueAsBool}\pysiglinewithargsret{\bfcode{getValueAsBool}}{}{}~\phantomsection\label{libopenzwave:getvalueasbool}
Gets a value as a bool.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}, {\hyperref[libopenzwave:getvaluecommandclass]{getValueCommandClass}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueAsByte() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueAsByte}\pysiglinewithargsret{\bfcode{getValueAsByte}}{}{}~\phantomsection\label{libopenzwave:getvalueasbyte}
Gets a value as an 8-bit unsigned integer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}, {\hyperref[libopenzwave:getvaluecommandclass]{getValueCommandClass}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueAsFloat() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueAsFloat}\pysiglinewithargsret{\bfcode{getValueAsFloat}}{}{}~\phantomsection\label{libopenzwave:getvalueasfloat}
Gets a value as a float.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value

\item[{Return type}] \leavevmode
float

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueAsInt() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueAsInt}\pysiglinewithargsret{\bfcode{getValueAsInt}}{}{}~\phantomsection\label{libopenzwave:getvalueasint}
Gets a value as a 32-bit signed integer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueAsShort() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueAsShort}\pysiglinewithargsret{\bfcode{getValueAsShort}}{}{}~\phantomsection\label{libopenzwave:getvalueasshort}
Gets a value as a 16-bit signed integer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueAsString() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueAsString}\pysiglinewithargsret{\bfcode{getValueAsString}}{}{}~\phantomsection\label{libopenzwave:getvalueasstring}
Gets a value as a string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueCommandClass() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueCommandClass}\pysiglinewithargsret{\bfcode{getValueCommandClass}}{}{}~\phantomsection\label{libopenzwave:getvaluecommandclass}
Get the command class instance of this value.  It is possible for there to be
multiple instances of a command class, although currently it appears that
only the SensorMultilevel command class ever does this.  Knowledge of
instances and command classes is not required to use OpenZWave, but this
information is exposed in case it is of interest.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The command class of the value

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvaluegenre]{getValueGenre}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueFloatPrecision() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueFloatPrecision}\pysiglinewithargsret{\bfcode{getValueFloatPrecision}}{}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The unique identifier of the value.

\item[{Returns}] \leavevmode
a float value's precision.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueGenre() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueGenre}\pysiglinewithargsret{\bfcode{getValueGenre}}{}{}~\phantomsection\label{libopenzwave:getvaluegenre}
Get the genre of the value.  The genre classifies a value to enable
low-level system or configuration parameters to be filtered out
by the application
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
A string containing the type of the value

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\color{red}\bfseries{}getValueCommandClass\_getValueAsString\_}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueHelp() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueHelp}\pysiglinewithargsret{\bfcode{getValueHelp}}{}{}~\phantomsection\label{libopenzwave:getvaluehelp}
Gets a help string describing the value's purpose and usage.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
A string containing the value help text.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setvaluehelp]{setValueHelp}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueIndex() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueIndex}\pysiglinewithargsret{\bfcode{getValueIndex}}{}{}~\phantomsection\label{libopenzwave:getvalueindex}
Get the value index.  The index is used to identify one of multiple
values created and managed by a command class.  In the case of configurable
parameters (handled by the configuration command class), the index is the
same as the parameter ID.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
A string containing the type of the value

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvaluecommandclass]{getValueCommandClass}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueInstance() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueInstance}\pysiglinewithargsret{\bfcode{getValueInstance}}{}{}~\phantomsection\label{libopenzwave:getvalueinstance}
Get the command class instance of this value.  It is possible for there to be
multiple instances of a command class, although currently it appears that
only the SensorMultilevel command class ever does this.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
A string containing the type of the value

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvaluecommandclass]{getValueCommandClass}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueLabel() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueLabel}\pysiglinewithargsret{\bfcode{getValueLabel}}{}{}~\phantomsection\label{libopenzwave:getvaluelabel}
Gets the user-friendly label for the value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
A string containing the user-friendly label of the value

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setvaluelabel]{setValueLabel}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueListItems() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueListItems}\pysiglinewithargsret{\bfcode{getValueListItems}}{}{}~\phantomsection\label{libopenzwave:getvaluelistitems}
Gets the list of items from a list value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The list of possible values

\item[{Return type}] \leavevmode
set()

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}} {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueListSelectionNum() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueListSelectionNum}\pysiglinewithargsret{\bfcode{getValueListSelectionNum}}{}{}~\phantomsection\label{libopenzwave:getvaluelistselectionnum}
Gets value of items from a list value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}},getValueAsFloat\_, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueListSelectionStr() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueListSelectionStr}\pysiglinewithargsret{\bfcode{getValueListSelectionStr}}{}{}~\phantomsection\label{libopenzwave:getvaluelistselectionstr}
Gets value of items from a list value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}},getValueAsFloat\_, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueMax() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueMax}\pysiglinewithargsret{\bfcode{getValueMax}}{}{}~\phantomsection\label{libopenzwave:getvaluemax}
Gets the maximum that this value may contain.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value maximum.

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getvaluemin]{getValueMin}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueMin() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueMin}\pysiglinewithargsret{\bfcode{getValueMin}}{}{}~\phantomsection\label{libopenzwave:getvaluemin}
Gets the minimum that this value may contain.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
The value minimum.

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getvaluemax]{getValueMax}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueType() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueType}\pysiglinewithargsret{\bfcode{getValueType}}{}{}~\phantomsection\label{libopenzwave:getvaluetype}
Gets the type of the value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
A string containing the type of the value

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvalueset]{isValueSet}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvaluelistselectionstr]{getValueListSelectionStr}} , {\hyperref[libopenzwave:getvaluelistselectionnum]{getValueListSelectionNum}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}, {\hyperref[libopenzwave:getvaluecommandclass]{getValueCommandClass}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getValueUnits() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.getValueUnits}\pysiglinewithargsret{\bfcode{getValueUnits}}{}{}~\phantomsection\label{libopenzwave:getvalueunits}
Gets the units that the value is measured in.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
A string containing the value of the units.

\item[{Return type}] \leavevmode
str

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setvalueunits]{setValueUnits}}

\end{description}\end{quote}

\end{fulllineitems}

\index{healNetwork() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.healNetwork}\pysiglinewithargsret{\bfcode{healNetwork}}{}{}~\phantomsection\label{libopenzwave:healnetwork}
Heal network by requesting node's rediscover their neighbors.
Sends a ControllerCommand\_RequestNodeNeighborUpdate to every node.
Can take a while on larger networks.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{upNodeRoute} (\emph{bool}) -- Optional Whether to perform return routes initialization. (default = false).

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:healnetworknode]{healNetworkNode}}

\end{description}\end{quote}

\end{fulllineitems}

\index{healNetworkNode() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.healNetworkNode}\pysiglinewithargsret{\bfcode{healNetworkNode}}{}{}~\phantomsection\label{libopenzwave:healnetworknode}
Heal network node by requesting the node rediscover their neighbors.
Sends a ControllerCommand\_RequestNodeNeighborUpdate to the node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeid} (\emph{int}) -- The ID of the node to query.

\item {} 
\textbf{upNodeRoute} (\emph{bool}) -- Optional Whether to perform return routes initialization. (default = false).

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:healnetwork]{healNetwork}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isBridgeController() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isBridgeController}\pysiglinewithargsret{\bfcode{isBridgeController}}{}{}~\phantomsection\label{libopenzwave:isbridgecontroller}
Query if the controller is using the bridge controller library.

A bridge controller is able to create virtual nodes that can be associated
with other controllers to enable events to be passed on.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
True if it is a bridge controller, False if not.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isprimarycontroller]{isPrimaryController}}, {\hyperref[libopenzwave:isstaticupdatecontroller]{isStaticUpdateController}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeAwake() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isNodeAwake}\pysiglinewithargsret{\bfcode{isNodeAwake}}{}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if the node is awake.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeBeamingDevice() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isNodeBeamingDevice}\pysiglinewithargsret{\bfcode{isNodeBeamingDevice}}{}{}~\phantomsection\label{libopenzwave:isnodebeamingdevice}
Get whether the node is a beam capable device.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if the node is a beaming device

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isnodelisteningdevice]{isNodeListeningDevice}}, {\hyperref[libopenzwave:isnodefrequentlisteningdevice]{isNodeFrequentListeningDevice}}, {\hyperref[libopenzwave:isnodesecuritydevice]{isNodeSecurityDevice}}, {\hyperref[libopenzwave:isnoderoutingdevice]{isNodeRoutingDevice}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeFailed() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isNodeFailed}\pysiglinewithargsret{\bfcode{isNodeFailed}}{}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if the node has failed and is no longer part of the network.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeFrequentListeningDevice() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isNodeFrequentListeningDevice}\pysiglinewithargsret{\bfcode{isNodeFrequentListeningDevice}}{}{}~\phantomsection\label{libopenzwave:isnodefrequentlisteningdevice}
Get whether the node is a frequent setening device that goes to sleep but
can be woken up by a beam. Useful to determine node and controller consistency.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if it is a frequent setening node.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isnodebeamingdevice]{isNodeBeamingDevice}}, {\hyperref[libopenzwave:isnodelisteningdevice]{isNodeListeningDevice}}, {\hyperref[libopenzwave:isnodesecuritydevice]{isNodeSecurityDevice}}, {\hyperref[libopenzwave:isnoderoutingdevice]{isNodeRoutingDevice}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeInfoReceived() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isNodeInfoReceived}\pysiglinewithargsret{\bfcode{isNodeInfoReceived}}{}{}~\phantomsection\label{libopenzwave:isnodeinforeceived}
Get whether the node information has been received
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
bool -- True if the node information has been received yet

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeListeningDevice() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isNodeListeningDevice}\pysiglinewithargsret{\bfcode{isNodeListeningDevice}}{}{}~\phantomsection\label{libopenzwave:isnodelisteningdevice}
Get whether the node is a setening device that does not go to sleep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if it is a setening node.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isnodebeamingdevice]{isNodeBeamingDevice}}, {\hyperref[libopenzwave:isnodefrequentlisteningdevice]{isNodeFrequentListeningDevice}}, {\hyperref[libopenzwave:isnodesecuritydevice]{isNodeSecurityDevice}}, {\hyperref[libopenzwave:isnoderoutingdevice]{isNodeRoutingDevice}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeRoutingDevice() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isNodeRoutingDevice}\pysiglinewithargsret{\bfcode{isNodeRoutingDevice}}{}{}~\phantomsection\label{libopenzwave:isnoderoutingdevice}
Get whether the node is a routing device that passes messages to other nodes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if the node is a routing device

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isnodebeamingdevice]{isNodeBeamingDevice}}, {\hyperref[libopenzwave:isnodelisteningdevice]{isNodeListeningDevice}}, {\hyperref[libopenzwave:isnodefrequentlisteningdevice]{isNodeFrequentListeningDevice}}, {\hyperref[libopenzwave:isnodesecuritydevice]{isNodeSecurityDevice}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeSecurityDevice() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isNodeSecurityDevice}\pysiglinewithargsret{\bfcode{isNodeSecurityDevice}}{}{}~\phantomsection\label{libopenzwave:isnodesecuritydevice}
Get the security attribute for a node. True if node supports security features.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if security features implemented.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isnodebeamingdevice]{isNodeBeamingDevice}}, {\hyperref[libopenzwave:isnodelisteningdevice]{isNodeListeningDevice}}, {\hyperref[libopenzwave:isnodefrequentlisteningdevice]{isNodeFrequentListeningDevice}}, {\hyperref[libopenzwave:isnoderoutingdevice]{isNodeRoutingDevice}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isPolled() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isPolled}\pysiglinewithargsret{\bfcode{isPolled}}{}{}~\phantomsection\label{libopenzwave:ispolled}
Check polling status of a value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of the value to check polling.

\item[{Returns}] \leavevmode
True if polling is active.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getpollinterval]{getPollInterval}}, {\hyperref[libopenzwave:setpollinterval]{setPollInterval}}, {\hyperref[libopenzwave:enablepoll]{enablePoll}}, {\hyperref[libopenzwave:setpollintensity]{setPollIntensity}}, {\hyperref[libopenzwave:disablepoll]{disablePoll}}, {\hyperref[libopenzwave:getpollintensity]{getPollIntensity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isPrimaryController() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isPrimaryController}\pysiglinewithargsret{\bfcode{isPrimaryController}}{}{}~\phantomsection\label{libopenzwave:isprimarycontroller}
Query if the controller is a primary controller.

The primary controller is the main device used to configure and control a
Z-Wave network.  There can only be one primary controller - all other
controllers are secondary controllers.

The only difference between a primary and secondary controller is that the
primary is the only one that can be used to add or remove other devices.  For
this reason, it is usually better for the promary controller to be portable,
since most devices must be added when installed in their final location.

Calls to BeginControllerCommand will fail if the controller is not the primary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
True if it is a primary controller, False if not.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isbridgecontroller]{isBridgeController}}, {\hyperref[libopenzwave:isstaticupdatecontroller]{isStaticUpdateController}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isStaticUpdateController() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isStaticUpdateController}\pysiglinewithargsret{\bfcode{isStaticUpdateController}}{}{}~\phantomsection\label{libopenzwave:isstaticupdatecontroller}
Query if the controller is a static update controller (SUC).

A Static Update Controller (SUC) is a controller that must never be moved in
normal operation and which can be used by other nodes to receive information
about network changes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller.

\item[{Returns}] \leavevmode
True if it is a static update controller, False if not.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isbridgecontroller]{isBridgeController}}, {\hyperref[libopenzwave:isprimarycontroller]{isPrimaryController}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isValuePolled() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isValuePolled}\pysiglinewithargsret{\bfcode{isValuePolled}}{}{}~\phantomsection\label{libopenzwave:isvaluepolled}
Test whether the value is currently being polled.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- the ID of a value.

\item[{Returns}] \leavevmode
True if the value is being polled, otherwise false.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{isValueReadOnly() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isValueReadOnly}\pysiglinewithargsret{\bfcode{isValueReadOnly}}{}{}~\phantomsection\label{libopenzwave:isvaluereadonly}
Test whether the value is read-only.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
True if the value cannot be changed by the user.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvaluewriteonly]{isValueWriteOnly}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isValueSet() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isValueSet}\pysiglinewithargsret{\bfcode{isValueSet}}{}{}~\phantomsection\label{libopenzwave:isvalueset}
Test whether the value has been set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- the ID of a value.

\item[{Returns}] \leavevmode
True if the value has actually been set by a status message from the device, rather than simply being the default.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getvalue]{getValue}}, {\hyperref[libopenzwave:getvalueasbool]{getValueAsBool}}, {\hyperref[libopenzwave:getvalueasbyte]{getValueAsByte}}, {\hyperref[libopenzwave:getvaluelistitems]{getValueListItems}}, {\hyperref[libopenzwave:getvalueasfloat]{getValueAsFloat}}, {\hyperref[libopenzwave:getvalueasshort]{getValueAsShort}}, {\hyperref[libopenzwave:getvalueasint]{getValueAsInt}}, {\hyperref[libopenzwave:getvalueasstring]{getValueAsString}}, {\hyperref[libopenzwave:getvaluetype]{getValueType}}, {\hyperref[libopenzwave:getvalueinstance]{getValueInstance}}, {\hyperref[libopenzwave:getvalueindex]{getValueIndex}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isValueWriteOnly() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.isValueWriteOnly}\pysiglinewithargsret{\bfcode{isValueWriteOnly}}{}{}~\phantomsection\label{libopenzwave:isvaluewriteonly}
Test whether the value is write-only.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a value.

\item[{Returns}] \leavevmode
True if the value can only be written to and not read.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:isvaluereadonly]{isValueReadOnly}}

\end{description}\end{quote}

\end{fulllineitems}

\index{logDriverStatistics() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.logDriverStatistics}\pysiglinewithargsret{\bfcode{logDriverStatistics}}{}{}~\phantomsection\label{libopenzwave:logdriverstatistics}
Send current driver statistics to the log file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller.

\end{description}\end{quote}

\end{fulllineitems}

\index{pressButton() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.pressButton}\pysiglinewithargsret{\bfcode{pressButton}}{}{}~\phantomsection\label{libopenzwave:pressbutton}
Starts an activity in a device.
Since buttons are write-only values that do not report a state,
no notification callbacks are sent.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of an integer value.

\item[{Returns}] \leavevmode
True if the activity was started. Returns false if the value is not a ValueID::ValueType\_Button. The type can be tested with a call to ValueID::GetType.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:releasebutton]{releaseButton}}

\end{description}\end{quote}

\end{fulllineitems}

\index{refreshNodeInfo() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.refreshNodeInfo}\pysiglinewithargsret{\bfcode{refreshNodeInfo}}{}{}~\phantomsection\label{libopenzwave:refreshnodeinfo}
Trigger the fetching of fixed data about a node.

Causes the nodes data to be obtained from the Z-Wave network in the same way
as if it had just been added.  This method would normally be called
automatically by OpenZWave, but if you know that a node has been changed,
calling this method will force a refresh of the data held by the library.  This
can be especially useful for devices that were asleep when the application was
first run.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if the request was sent successfully.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{refreshValue() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.refreshValue}\pysiglinewithargsret{\bfcode{refreshValue}}{}{}~\phantomsection\label{libopenzwave:refreshvalue}
Refreshes the specified value from the Z-Wave network.
A call to this function causes the library to send a message to the network to retrieve the current value
of the specified ValueID (just like a poll, except only one-time, not recurring).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The unique identifier of the value to be refreshed.

\item[{Returns}] \leavevmode
bool -- True if the driver and node were found; false otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{releaseButton() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.releaseButton}\pysiglinewithargsret{\bfcode{releaseButton}}{}{}~\phantomsection\label{libopenzwave:releasebutton}
Stops an activity in a device.
Since buttons are write-only values that do not report a state,
no notification callbacks are sent.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- the ID of an integer value.

\item[{Returns}] \leavevmode
True if the activity was stopped. Returns false if the value is not a ValueID::ValueType\_Button. The type can be tested with a call to ValueID::GetType.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:pressbutton]{pressButton}}

\end{description}\end{quote}

\end{fulllineitems}

\index{removeAllScenes() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.removeAllScenes}\pysiglinewithargsret{\bfcode{removeAllScenes}}{}{}~\phantomsection\label{libopenzwave:removeallscenes}
Delete all scenes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}

\end{description}\end{quote}

\end{fulllineitems}

\index{removeAssociation() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.removeAssociation}\pysiglinewithargsret{\bfcode{removeAssociation}}{}{}~\phantomsection\label{libopenzwave:removeassociation}
Removes a node from an association group.

Due to the possibility of a device being asleep, the command is assumed to
succeed, and the association data held in this class is updated directly.  This
will be reverted by a future Association message from the device if the Z-Wave
message actually failed to get through.   Notification callbacks will be sent
in both cases.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node whose associations are to be changed.

\item {} 
\textbf{groupIdx} (\emph{int}) -- One-based index of the group (because Z-Wave product manuals use one-based group numbering).

\item {} 
\textbf{targetNodeId} (\emph{int}) -- Identifier for the node that will be removed from the association group.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumgroups]{getNumGroups}}, {\hyperref[libopenzwave:getassociations]{getAssociations}}, {\hyperref[libopenzwave:getmaxassociations]{getMaxAssociations}}, {\hyperref[libopenzwave:addassociation]{addAssociation}}

\end{description}\end{quote}

\end{fulllineitems}

\index{removeDriver() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.removeDriver}\pysiglinewithargsret{\bfcode{removeDriver}}{}{}~\phantomsection\label{libopenzwave:removedriver}
Removes the driver for a Z-Wave controller, and closes the controller.

Drivers do not need to be explicitly removed before calling Destroy - this is
handled automatically.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{serialport} (\emph{str}) -- The same string as was passed in the original call toAddDriver.

\item[{Returns}] \leavevmode
True if the driver was removed, False if it could not be found.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:adddriver]{addDriver}}

\end{description}\end{quote}

\end{fulllineitems}

\index{removeScene() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.removeScene}\pysiglinewithargsret{\bfcode{removeScene}}{}{}~\phantomsection\label{libopenzwave:removescene}
Remove an existing Scene.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{sceneId} (\emph{int}) -- The unique Scene ID to be removed.

\item[{Returns}] \leavevmode
True if scene was removed.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}

\end{description}\end{quote}

\end{fulllineitems}

\index{removeSceneValue() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.removeSceneValue}\pysiglinewithargsret{\bfcode{removeSceneValue}}{}{}~\phantomsection\label{libopenzwave:removescenevalue}
Remove the Value ID from an existing scene.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sceneid} (\emph{int}) -- The ID of a scene.

\item {} 
\textbf{id} (\emph{int}) -- The ID of a value.

\end{itemize}

\item[{Returns}] \leavevmode
True if succee. False otherwise

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}

\end{description}\end{quote}

\end{fulllineitems}

\index{removeSwitchPoint() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.removeSwitchPoint}\pysiglinewithargsret{\bfcode{removeSwitchPoint}}{}{}~\phantomsection\label{libopenzwave:removeswitchpoint}
Remove a switch point from the schedule
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The unique identifier of the schedule value.

\item {} 
\textbf{hours} (\emph{int}) -- The hours part of the time when the switch point will trigger.  The time is set using the 24-hour clock, so this value must be between 0 and 23.

\item {} 
\textbf{minutes} (\emph{int}) -- The minutes part of the time when the switch point will trigger.  This value must be between 0 and 59.

\end{itemize}

\item[{Returns}] \leavevmode
True if the switch point is removed.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setswitchpoint]{setSwitchPoint}}, {\hyperref[libopenzwave:clearswitchpoints]{clearSwitchPoints}}, {\hyperref[libopenzwave:getswitchpoint]{getSwitchPoint}}, {\hyperref[libopenzwave:getnumswitchpoints]{getNumSwitchPoints}}

\end{description}\end{quote}

\end{fulllineitems}

\index{removeWatcher() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.removeWatcher}\pysiglinewithargsret{\bfcode{removeWatcher}}{}{}~\phantomsection\label{libopenzwave:removewatcher}
Remove a notification watcher.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{pythonfunc} (\emph{callback}) -- Watcher pointer to a function

\item[{See}] \leavevmode
{\hyperref[libopenzwave:addwatcher]{addWatcher}}

\end{description}\end{quote}

\end{fulllineitems}

\index{requestAllConfigParams() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.requestAllConfigParams}\pysiglinewithargsret{\bfcode{requestAllConfigParams}}{}{}~\phantomsection\label{libopenzwave:requestallconfigparams}
Request the values of all known configurable parameters from a device.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to configure.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:requestconfigparam]{requestConfigParam}}, {\hyperref[libopenzwave:setconfigparam]{setConfigParam}}, {\color{red}\bfseries{}valueID\_}, {\color{red}\bfseries{}notification\_}

\end{description}\end{quote}

\end{fulllineitems}

\index{requestConfigParam() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.requestConfigParam}\pysiglinewithargsret{\bfcode{requestConfigParam}}{}{}~\phantomsection\label{libopenzwave:requestconfigparam}
Request the value of a configurable parameter from a device.

Some devices have various parameters that can be configured to control the
device behaviour.  These are not reported by the device over the Z-Wave network
but can usually be found in the devices user manual.  This method requests
the value of a parameter from the device, and then returns immediately,
without waiting for a response.  If the parameter index is valid for this
device, and the device is awake, the value will eventually be reported via a
ValueChanged notification callback.  The ValueID reported in the callback will
have an index set the same as \_param and a command class set to the same value
as returned by a call to Configuration::StaticGetCommandClassId.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to configure.

\item {} 
\textbf{param} (\emph{int}) -- The index of the parameter.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:requestallconfigparams]{requestAllConfigParams}}, {\hyperref[libopenzwave:setconfigparam]{setConfigParam}}, {\color{red}\bfseries{}valueID\_}, {\color{red}\bfseries{}notification\_}

\end{description}\end{quote}

\end{fulllineitems}

\index{requestNodeDynamic() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.requestNodeDynamic}\pysiglinewithargsret{\bfcode{requestNodeDynamic}}{}{}~\phantomsection\label{libopenzwave:requestnodedynamic}
Trigger the fetching of fixed data about a node.

Causes the nodes data to be obtained from the Z-Wave network in the same way
as if it had just been added.  This method would normally be called
automatically by OpenZWave, but if you know that a node has been changed,
calling this method will force a refresh of the data held by the library.  This
can be especially useful for devices that were asleep when the application was
first run.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if the request was sent successfully.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{requestNodeState() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.requestNodeState}\pysiglinewithargsret{\bfcode{requestNodeState}}{}{}~\phantomsection\label{libopenzwave:requestnodestate}
Trigger the fetching of just the dynamic value data for a node.
Causes the node's values to be requested from the Z-Wave network. This is the
same as the query state starting from the dynamic state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\end{itemize}

\item[{Returns}] \leavevmode
True if the request was sent successfully.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{resetController() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.resetController}\pysiglinewithargsret{\bfcode{resetController}}{}{}~\phantomsection\label{libopenzwave:resetcontroller}
Hard Reset a PC Z-Wave Controller.

Resets a controller and erases its network configuration settings.  The
controller becomes a primary controller ready to add devices to a new network.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller to be reset.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:softresetcontroller]{softResetController}}

\end{description}\end{quote}

\end{fulllineitems}

\index{sceneExists() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.sceneExists}\pysiglinewithargsret{\bfcode{sceneExists}}{}{}~\phantomsection\label{libopenzwave:sceneexists}
Check if a Scene ID is defined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{sceneId} (\emph{int}) -- The ID of the scene to check.

\item[{Returns}] \leavevmode
True if Scene ID exists.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}

\end{description}\end{quote}

\end{fulllineitems}

\index{sceneGetValues() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.sceneGetValues}\pysiglinewithargsret{\bfcode{sceneGetValues}}{}{}~\phantomsection\label{libopenzwave:scenegetvalues}
Retrieve the list of values from a scene.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The ID of a scene.

\item[{Return type}] \leavevmode
dict()

\item[{Returns}] \leavevmode
A dict containing : \{valueid : value, ...\}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setChangeVerified() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setChangeVerified}\pysiglinewithargsret{\bfcode{setChangeVerified}}{}{}~
If so, the library will immediately refresh the value a second time whenever a change is observed. This helps to filter out spurious data reported occasionally by some devices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id} (\emph{int}) -- The unique identifier of the value whose changes should or should not be verified.

\end{description}\end{quote}

:param verify if true, verify changes; if false, don't verify changes
:type verify: bool

\end{fulllineitems}

\index{setConfigParam() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setConfigParam}\pysiglinewithargsret{\bfcode{setConfigParam}}{}{}~\phantomsection\label{libopenzwave:setconfigparam}
Set the value of a configurable parameter in a device.

Some devices have various parameters that can be configured to control the
device behaviour.  These are not reported by the device over the Z-Wave network
but can usually be found in the devices user manual.  This method returns
immediately, without waiting for confirmation from the device that the change
has been made.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to configure.

\item {} 
\textbf{param} (\emph{int}) -- The index of the parameter.

\item {} 
\textbf{value} (\emph{int}) -- The value to which the parameter should be set.

\item {} 
\textbf{size} (\emph{int}) -- Is an optional number of bytes to be sent for the parameter value. Defaults to 2.

\end{itemize}

\item[{Returns}] \leavevmode
True if the message setting the value was sent to the device.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:requestconfigparam]{requestConfigParam}}, {\hyperref[libopenzwave:requestallconfigparams]{requestAllConfigParams}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setNodeLevel() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setNodeLevel}\pysiglinewithargsret{\bfcode{setNodeLevel}}{}{}~\phantomsection\label{libopenzwave:setnodelevel}
Sets the basic level of a node

This is a helper method to simplify basic control of a node.  It is the
equivalent of changing the value reported by the nodes Basic command class
and will generate a ValueChanged notification from that class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to be changed.

\item {} 
\textbf{level} (\emph{int}) -- The level to set the node.  Valid values are 0-99 and 255.  Zero is off and 99 is fully on.  255 will turn on the device at its last known level (if supported).

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setnodeon]{setNodeOn}}, {\hyperref[libopenzwave:setnodeoff]{setNodeOff}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setNodeLocation() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setNodeLocation}\pysiglinewithargsret{\bfcode{setNodeLocation}}{}{}~\phantomsection\label{libopenzwave:setnodelocation}
Set the location of a node

The node location is a user-editable string that would normally be handled by
the Node Naming commmand class, but many devices do not support it.  So that a
node can always report its location, OpenZWave stores it with the node data,
and provides access through this method and GetNodeLocation, rather than
reporting it via a command class Value object.  If the device does support the
Node Naming command class, the new location will be sent to the node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\item {} 
\textbf{location} (\emph{int}) -- A string containing the nodes location.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodelocation]{getNodeLocation}}, {\hyperref[libopenzwave:getnodename]{getNodeName}}, {\hyperref[libopenzwave:setnodename]{setNodeName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setNodeManufacturerName() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setNodeManufacturerName}\pysiglinewithargsret{\bfcode{setNodeManufacturerName}}{}{}~\phantomsection\label{libopenzwave:setnodemanufacturername}
Set the manufacturer name of a device

The manufacturer name would normally be handled by the Manufacturer Specific
commmand class, taking the manufacturer ID reported by the device and using it
to look up the name from the manufacturer\_specific.xml file in the OpenZWave
config folder.  However, there are some devices that do not support the command
class, so to enable the user to manually set the name, it is stored with the
node data and accessed via this method rather than being reported via a command
class Value object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\item {} 
\textbf{manufacturerName} (\emph{str}) -- A string containing the nodess manufacturer name.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodemanufacturername]{getNodeManufacturerName}}, {\hyperref[libopenzwave:getnodeproductname]{getNodeProductName}}, {\hyperref[libopenzwave:setnodeproductname]{setNodeProductName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setNodeName() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setNodeName}\pysiglinewithargsret{\bfcode{setNodeName}}{}{}~\phantomsection\label{libopenzwave:setnodename}
Set the name of a node

The node name is a user-editable label for the node that would normally be
handled by the Node Naming commmand class, but many devices do not support it.
So that a node can always be named, OpenZWave stores it with the node data, and
provides access through this method and GetNodeName, rather than reporting it
via a command class Value object.  If the device does support the Node Naming
command class, the new name will be sent to the node.  The maximum length of a
node name is 16 characters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeI} -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\item {} 
\textbf{nodeName} (\emph{str}) -- A string containing the nodes name.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodename]{getNodeName}}, {\hyperref[libopenzwave:getnodelocation]{getNodeLocation}}, {\hyperref[libopenzwave:setnodelocation]{setNodeLocation}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setNodeOff() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setNodeOff}\pysiglinewithargsret{\bfcode{setNodeOff}}{}{}~\phantomsection\label{libopenzwave:setnodeoff}
Turns a node off

This is a helper method to simplify basic control of a node.  It is the
equivalent of changing the level reported by the nodes Basic command class to
zero, and will generate a ValueChanged notification from that class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to be changed.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setnodeon]{setNodeOn}}, {\hyperref[libopenzwave:setnodelevel]{setNodeLevel}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setNodeOn() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setNodeOn}\pysiglinewithargsret{\bfcode{setNodeOn}}{}{}~\phantomsection\label{libopenzwave:setnodeon}
Turns a node on

This is a helper method to simplify basic control of a node.  It is the
equivalent of changing the level reported by the nodes Basic command class to
255, and will generate a ValueChanged notification from that class.  This
command will turn on the device at its last known level, if supported by the
device, otherwise it will turn it on at 100\%.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to be changed.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:setnodeoff]{setNodeOff}}, {\hyperref[libopenzwave:setnodelevel]{setNodeLevel}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setNodeProductName() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setNodeProductName}\pysiglinewithargsret{\bfcode{setNodeProductName}}{}{}~\phantomsection\label{libopenzwave:setnodeproductname}
Set the product name of a device

The product name would normally be handled by the Manufacturer Specific
commmand class, taking the product Type and ID reported by the device and using
it to look up the name from the manufacturer\_specific.xml file in the OpenZWave
config folder.  However, there are some devices that do not support the command
class, so to enable the user to manually set the name, it is stored with the
node data and accessed via this method rather than being reported via a command
class Value object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeId} (\emph{int}) -- The ID of the node to query.

\item {} 
\textbf{productName} (\emph{str}) -- A string containing the nodes product name.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnodeproductname]{getNodeProductName}}, {\hyperref[libopenzwave:getnodemanufacturername]{getNodeManufacturerName}}, {\hyperref[libopenzwave:setnodemanufacturername]{setNodeManufacturerName}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setPollIntensity() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setPollIntensity}\pysiglinewithargsret{\bfcode{setPollIntensity}}{}{}~\phantomsection\label{libopenzwave:setpollintensity}
Set the frequency of polling (0=none, 1=every time through the set, 2-every other time, etc)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The ID of the value whose intensity should be set

\item {} 
\textbf{intensity} (\emph{int}) -- the intensity of the poll

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getpollinterval]{getPollInterval}}, {\hyperref[libopenzwave:setpollinterval]{setPollInterval}}, {\hyperref[libopenzwave:enablepoll]{enablePoll}}, {\hyperref[libopenzwave:ispolled]{isPolled}}, {\hyperref[libopenzwave:disablepoll]{disablePoll}}, {\hyperref[libopenzwave:getpollintensity]{getPollIntensity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setPollInterval() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setPollInterval}\pysiglinewithargsret{\bfcode{setPollInterval}}{}{}~\phantomsection\label{libopenzwave:setpollinterval}
Set the time period between polls of a nodes state.

Due to patent concerns, some devices do not report state changes automatically
to the controller.  These devices need to have their state polled at regular
intervals.  The length of the interval is the same for all devices.  To even
out the Z-Wave network traffic generated by polling, OpenZWave divides the
polling interval by the number of devices that have polling enabled, and polls
each in turn.  It is recommended that if possible, the interval should not be
set shorter than the number of polled devices in seconds (so that the network
does not have to cope with more than one poll per second).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{milliseconds} (\emph{int}) -- The length of the polling interval in milliseconds.

\item {} 
\textbf{bIntervalBetweenPolls} (\emph{bool}) -- If true, the library intersperses m\_pollInterval between polls.
If false, the library attempts to complete all polls within m\_pollInterval

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getpollinterval]{getPollInterval}}, {\hyperref[libopenzwave:enablepoll]{enablePoll}}, {\hyperref[libopenzwave:ispolled]{isPolled}}, {\hyperref[libopenzwave:setpollintensity]{setPollIntensity}}, {\hyperref[libopenzwave:disablepoll]{disablePoll}}, {\hyperref[libopenzwave:getpollintensity]{getPollIntensity}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setSceneLabel() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setSceneLabel}\pysiglinewithargsret{\bfcode{setSceneLabel}}{}{}~\phantomsection\label{libopenzwave:setscenelabel}
Sets a label for the particular scene.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sceneId} (\emph{int}) -- The ID of the scene.

\item {} 
\textbf{value} (\emph{int}) -- The new value of the label.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:setscenevalue]{setSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setSceneValue() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setSceneValue}\pysiglinewithargsret{\bfcode{setSceneValue}}{}{}~\phantomsection\label{libopenzwave:setscenevalue}
Set a value to an existing scene's ValueID.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sceneid} (\emph{int}) -- The ID of a scene.

\item {} 
\textbf{id} (\emph{int}) -- The ID of a value.

\item {} 
\textbf{value} (\emph{bool, int, float, string}) -- The value to set

\end{itemize}

\item[{Returns}] \leavevmode
An integer representing the result of the operation
0 : The C method fails
1 : The C method succeed
2 : Can't find id in the map

\item[{Return type}] \leavevmode
int

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getnumscenes]{getNumScenes}}, {\hyperref[libopenzwave:getallscenes]{getAllScenes}}, {\hyperref[libopenzwave:sceneexists]{sceneExists}}, {\hyperref[libopenzwave:removeallscenes]{removeAllScenes}}, {\hyperref[libopenzwave:createscene]{createScene}}, {\hyperref[libopenzwave:removescene]{removeScene}}, {\hyperref[libopenzwave:activatescene]{activateScene}}, {\hyperref[libopenzwave:getscenelabel]{getSceneLabel}}, {\hyperref[libopenzwave:setscenelabel]{setSceneLabel}}, {\hyperref[libopenzwave:removescenevalue]{removeSceneValue}}, {\hyperref[libopenzwave:addscenevalue]{addSceneValue}}, {\hyperref[libopenzwave:scenegetvalues]{sceneGetValues}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setSwitchPoint() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setSwitchPoint}\pysiglinewithargsret{\bfcode{setSwitchPoint}}{}{}~\phantomsection\label{libopenzwave:setswitchpoint}
Set a switch point in the schedule.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The unique identifier of the schedule value.

\item {} 
\textbf{hours} (\emph{int}) -- The hours part of the time when the switch point will trigger. The time is set using the 24-hour clock, so this value must be between 0 and 23.

\item {} 
\textbf{minutes} (\emph{int}) -- The minutes part of the time when the switch point will trigger.  This value must be between 0 and 59.

\item {} 
\textbf{setback} (\emph{int}) -- The setback in tenths of a degree Celsius.  The setback value can range from -128 (-12.8C) to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and 122 is used to set Energy Saving mode.

\end{itemize}

\item[{Returns}] \leavevmode
True if the switch point is set.

\item[{Return type}] \leavevmode
bool

\item[{See}] \leavevmode
{\hyperref[libopenzwave:removeswitchpoint]{removeSwitchPoint}}, {\hyperref[libopenzwave:clearswitchpoints]{clearSwitchPoints}}, {\hyperref[libopenzwave:getswitchpoint]{getSwitchPoint}}, {\hyperref[libopenzwave:getnumswitchpoints]{getNumSwitchPoints}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setValue() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setValue}\pysiglinewithargsret{\bfcode{setValue}}{}{}~\phantomsection\label{libopenzwave:setvalue}
Sets the value of a device valueid.
Due to the possibility of a device being asleep, the command is assumed to suceeed, and the value
held by the node is updated directly.  This will be reverted by a future status message from the device
if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The ID of a value.

\item {} 
\textbf{value} (\emph{int}) -- The value to set.

\end{itemize}

\item[{Returns}] \leavevmode
An integer representing the result of the operation  0 : The C method fails, 1 : The C method succeed, 2 : Can't find id in the map

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{setValueHelp() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setValueHelp}\pysiglinewithargsret{\bfcode{setValueHelp}}{}{}~\phantomsection\label{libopenzwave:setvaluehelp}
Sets a help string describing the value's purpose and usage.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- the ID of a value.

\item {} 
\textbf{help} (\emph{str}) -- The new value of the help text.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getvaluehelp]{getValueHelp}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setValueLabel() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setValueLabel}\pysiglinewithargsret{\bfcode{setValueLabel}}{}{}~\phantomsection\label{libopenzwave:setvaluelabel}
Sets the user-friendly label for the value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The ID of a value.

\item {} 
\textbf{label} (\emph{str}) -- The label of the value.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getvaluelabel]{getValueLabel}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setValueUnits() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.setValueUnits}\pysiglinewithargsret{\bfcode{setValueUnits}}{}{}~\phantomsection\label{libopenzwave:setvalueunits}
Sets the units that the value is measured in.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{id} (\emph{int}) -- The ID of a value.

\item {} 
\textbf{label} (\emph{str}) -- The new value of the units.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:getvalueunits]{getValueUnits}}

\end{description}\end{quote}

\end{fulllineitems}

\index{softResetController() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.softResetController}\pysiglinewithargsret{\bfcode{softResetController}}{}{}~\phantomsection\label{libopenzwave:softresetcontroller}
Soft Reset a PC Z-Wave Controller.

Resets a controller without erasing its network configuration settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller to be reset.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:resetcontroller]{resetController}}

\end{description}\end{quote}

\end{fulllineitems}

\index{switchAllOff() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.switchAllOff}\pysiglinewithargsret{\bfcode{switchAllOff}}{}{}~\phantomsection\label{libopenzwave:switchalloff}
Switch all devices off.  All devices that support the SwitchAll command class
will be turned off.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:switchallon]{switchAllOn}}

\end{description}\end{quote}

\end{fulllineitems}

\index{switchAllOn() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.switchAllOn}\pysiglinewithargsret{\bfcode{switchAllOn}}{}{}~\phantomsection\label{libopenzwave:switchallon}
Switch all devices on.  All devices that support the SwitchAll command class
will be turned on.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeId} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item[{See}] \leavevmode
{\hyperref[libopenzwave:switchalloff]{switchAllOff}}

\end{description}\end{quote}

\end{fulllineitems}

\index{testNetwork() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.testNetwork}\pysiglinewithargsret{\bfcode{testNetwork}}{}{}~\phantomsection\label{libopenzwave:testnetwork}
Test network.

Sends a series of messages to every node on the network for testing network reliability.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{count} (\emph{int}) -- This is the number of test messages to send.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:testnetworknode]{testNetworkNode}}

\end{description}\end{quote}

\end{fulllineitems}

\index{testNetworkNode() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.testNetworkNode}\pysiglinewithargsret{\bfcode{testNetworkNode}}{}{}~\phantomsection\label{libopenzwave:testnetworknode}
Test network node.

Sends a series of messages to a network node for testing network reliability.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller that manages the node.

\item {} 
\textbf{nodeid} (\emph{int}) -- The ID of the node to query.

\item {} 
\textbf{count} (\emph{int}) -- This is the number of test messages to send.

\end{itemize}

\item[{See}] \leavevmode
{\hyperref[libopenzwave:testnetwork]{testNetwork}}

\end{description}\end{quote}

\end{fulllineitems}

\index{writeConfig() (libopenzwave.PyManager method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyManager.writeConfig}\pysiglinewithargsret{\bfcode{writeConfig}}{}{}
Saves the configuration of a PC Controller's Z-Wave network to the
application's user data folder.

This method does not normally need to be called, since OpenZWave will save the
state automatically during the shutdown process.  It is provided here only as
an aid to development. The configuration of each PC Controller's Z-Wave network
is stored in a separate file.  The filename consists of the 8 digit hexadecimal
version of the controller's Home ID, prefixed with the string ``zwcfg\_*''.  This
convention allows OpenZWave to find the correct configuration file for a
controller, even if it is attached to a different serial port, USB device path,
etc.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{homeid} (\emph{int}) -- The Home ID of the Z-Wave controller to save.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PyOptions (class in libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyOptions}\pysigline{\strong{class }\code{libopenzwave.}\bfcode{PyOptions}}
Bases: \code{object}

Manage options manager
\index{addOptionBool() (libopenzwave.PyOptions method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyOptions.addOptionBool}\pysiglinewithargsret{\bfcode{addOptionBool}}{}{}
Add a boolean option.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{str}) -- The name of the option.

\item {} 
\textbf{value} (\emph{boolean}) -- The value of the option.

\end{itemize}

\item[{Returns}] \leavevmode
The result of the operation.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{addOptionInt() (libopenzwave.PyOptions method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyOptions.addOptionInt}\pysiglinewithargsret{\bfcode{addOptionInt}}{}{}
Add an integer option.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{str}) -- The name of the option.

\item {} 
\textbf{value} (\emph{boolean}) -- The value of the option.

\end{itemize}

\item[{Returns}] \leavevmode
The result of the operation.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{addOptionString() (libopenzwave.PyOptions method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyOptions.addOptionString}\pysiglinewithargsret{\bfcode{addOptionString}}{}{}
Add a string option.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{str}) -- The name of the option.  Option names are case insensitive and must be unique.

\item {} 
\textbf{value} (\emph{str}) -- The value of the option.

\item {} 
\textbf{append} (\emph{boolean}) -- Setting append to true will cause values read from the command line
or XML file to be concatenated into a comma delimited set.  If \_append is false,
newer values will overwrite older ones.

\end{itemize}

\item[{Returns}] \leavevmode
The result of the operation.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{create() (libopenzwave.PyOptions method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyOptions.create}\pysiglinewithargsret{\bfcode{create}}{}{}
Create an option object used to start the manager
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\emph{str}) -- The path of the config directory

\item {} 
\textbf{b} (\emph{str}) -- The path of the user directory

\item {} 
\textbf{c} (\emph{str}) -- The ``command line'' options of the openzwave library

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{getConfigPath() (libopenzwave.PyOptions method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyOptions.getConfigPath}\pysiglinewithargsret{\bfcode{getConfigPath}}{}{}~\phantomsection\label{libopenzwave:getconfigpath}
Retrieve the config path. This directory hold the xml files.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A string containing the library config path or None.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{lock() (libopenzwave.PyOptions method)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.PyOptions.lock}\pysiglinewithargsret{\bfcode{lock}}{}{}
Lock the options. Needed to start the manager
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The result of the operation.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RetAlloc (class in libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.RetAlloc}\pysigline{\strong{class }\code{libopenzwave.}\bfcode{RetAlloc}}
Bases: \code{object}

Map an array of uint8\_t used when retrieving sets.
Allocate memory at init and free it when no more reference to it exist.
Give it to lion as Nico0084 says : \href{http://blog.naviso.fr/wordpress/wp-sphinxdoc/uploads/2011/11/MemoryLeaks3.jpg}{http://blog.naviso.fr/wordpress/wp-sphinxdoc/uploads/2011/11/MemoryLeaks3.jpg}

\end{fulllineitems}

\index{configPath() (in module libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.configPath}\pysiglinewithargsret{\code{libopenzwave.}\bfcode{configPath}}{}{}
Retrieve the config path. This directory hold the xml files.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A string containing the library config path or None.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{driverData() (in module libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{libopenzwave:libopenzwave.driverData}\pysiglinewithargsret{\code{libopenzwave.}\bfcode{driverData}}{}{}
\end{fulllineitems}



\chapter{API documentation}
\label{openzwave:api-documentation}\label{openzwave::doc}
Contents:


\section{Network documentation}
\label{network:network-documentation}\label{network::doc}
This is the central point. Everything is attached to a network.
\phantomsection\label{network:module-openzwave.network}\index{openzwave.network (module)}\phantomsection\label{network:module-openzwave.network}\index{openzwave.network (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave API

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveNetwork (class in openzwave.network)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork}\pysiglinewithargsret{\strong{class }\code{openzwave.network.}\bfcode{ZWaveNetwork}}{\emph{options}, \emph{log=None}, \emph{autostart=True}}{}
The network objet = homeid.
It contains a reference to the manager and the controller.

It dispatch the following louie signals :
\begin{itemize}
\item {} 
SIGNAL\_NETWORK\_FAILED = `NetworkFailed'

\item {} 
SIGNAL\_NETWORK\_STARTED = `NetworkStarted'

\item {} 
SIGNAL\_NETWORK\_READY = `NetworkReady'

\item {} 
SIGNAL\_NETWORK\_STOPPED = `NetworkStopped'

\item {} 
SIGNAL\_NETWORK\_RESETTED = `DriverResetted'

\item {} 
SIGNAL\_NETWORK\_AWAKED = `DriverAwaked'

\item {} 
SIGNAL\_DRIVER\_FAILED = `DriverFailed'

\item {} 
SIGNAL\_DRIVER\_READY = `DriverReady'

\item {} 
SIGNAL\_DRIVER\_RESET = `DriverReset'

\item {} 
SIGNAL\_DRIVER\_REMOVED = `DriverRemoved'

\item {} 
SIGNAL\_NODE\_ADDED = `NodeAdded'

\item {} 
SIGNAL\_NODE\_EVENT = `NodeEvent'

\item {} 
SIGNAL\_NODE\_NAMING = `NodeNaming'

\item {} 
SIGNAL\_NODE\_NEW = `NodeNew'

\item {} 
SIGNAL\_NODE\_PROTOCOL\_INFO = `NodeProtocolInfo'

\item {} 
SIGNAL\_NODE\_READY = `NodeReady'

\item {} 
SIGNAL\_NODE\_REMOVED = `NodeRemoved'

\item {} 
SIGNAL\_SCENE\_EVENT = `SceneEvent'

\item {} 
SIGNAL\_VALUE\_ADDED = `ValueAdded'

\item {} 
SIGNAL\_VALUE\_CHANGED = `ValueChanged'

\item {} 
SIGNAL\_VALUE\_REFRESHED = `ValueRefreshed'

\item {} 
SIGNAL\_VALUE\_REMOVED = `ValueRemoved'

\item {} 
SIGNAL\_POLLING\_ENABLED = `PollingEnabled'

\item {} 
SIGNAL\_POLLING\_DISABLED = `PollingDisabled'

\item {} 
SIGNAL\_CREATE\_BUTTON = `CreateButton'

\item {} 
SIGNAL\_DELETE\_BUTTON = `DeleteButton'

\item {} 
SIGNAL\_BUTTON\_ON = `ButtonOn'

\item {} 
SIGNAL\_BUTTON\_OFF = `ButtonOff'

\item {} 
SIGNAL\_ESSENTIAL\_NODE\_QUERIES\_COMPLETE = `EssentialNodeQueriesComplete'

\item {} 
SIGNAL\_NODE\_QUERIES\_COMPLETE = `NodeQueriesComplete'

\item {} 
SIGNAL\_AWAKE\_NODES\_QUERIED = `AwakeNodesQueried'

\item {} 
SIGNAL\_ALL\_NODES\_QUERIED = `AllNodesQueried'

\item {} 
SIGNAL\_MSG\_COMPLETE = `MsgComplete'

\item {} 
SIGNAL\_ERROR = `Error'

\end{itemize}

The table presented below sets notifications in the order they might typically be received,
and grouped into a few logically related categories.  Of course, given the variety
of ZWave controllers, devices and network configurations the actual sequence will vary (somewhat).
The descriptions below the notification name (in square brackets) identify whether the
notification is always sent (unless theres a significant error in the network or software)
or potentially sent during the execution sequence.

Driver Initialization Notification

The notification below is sent when OpenZWave has successfully connected
to a physical ZWave controller.
\begin{itemize}
\item {} 
DriverReady

\end{itemize}

{[}always sent{]}   Sent when the driver (representing a connection between OpenZWave
and a Z-Wave controller attached to the specified serial (or HID) port) has been initialized.
At the time this notification is sent, only certain information about the controller itself is known:
\begin{itemize}
\item {} 
Controller Z-Wave version

\item {} 
Network HomeID

\item {} 
Controller capabilities

\item {} 
Controller Application Version \& Manufacturer/Product ID

\item {} 
Nodes included in the network

\end{itemize}
\begin{itemize}
\item {} 
DriverRemoved

\end{itemize}

{[}always sent (either due to Error or by request){]} The Driver is being removed.
Do Not Call Any Driver Related Methods after receiving this

Node Initialization Notifications

As OpenZWave starts, it identifies and reads information about each node in the network.
The following notifications may be sent during the initialization process.
\begin{itemize}
\item {} 
NodeNew

\end{itemize}

{[}potentially sent{]}  Sent when a new node has been identified as part of the Z-Wave network.
It is not sent if the node was identified in a prior execution of the OpenZWave library
and stored in the zwcfg*.xml file.
At the time this notification is sent, very little is known about the node itself...
only that it is new to OpenZWave. This message is sent once for each new node identified.
\begin{itemize}
\item {} 
NodeAdded

\end{itemize}

{[}always sent (for each node associated with the controller){]}
Sent when a node has been added to OpenZWaves set of nodes.  It can be
triggered either as the zwcfg*.xml file is being read, when a new node
is found on startup (see NodeNew notification above), or if a new node
is included in the network while OpenZWave is running.
As with NodeNew, very little is known about the node at the time the
notification is sentjust the fact that a new node has been identified
and its assigned NodeID.
\begin{itemize}
\item {} 
NodeProtocolInfo

\end{itemize}

{[}potentially sent{]}  Sent after a nodes protocol information has been
successfully read from the controller.
At the time this notification is sent, only certain information about the node is known:
\begin{itemize}
\item {} 
Whether it is a listening or sleeping device

\item {} 
Whether the node is capable of routing messages

\item {} 
Maximum baud rate for communication

\item {} 
Version number

\item {} 
Security byte

\end{itemize}

NodeNaming

{[}potentially sent{]}  Sent when a nodes name has been set or changed
(although it may be set to  or NULL).
\begin{itemize}
\item {} 
ValueAdded

\end{itemize}

{[}potentially sent{]}  Sent when a new value has been associated with the node.
At the time this notification is sent, the new value may or may not
have live data associated with it. It may be populated, but it may
alternatively just be a placeholder for a value that has not been read
at the time the notification is sent.
\begin{itemize}
\item {} 
NodeQueriesComplete

\end{itemize}

{[}always sent (for each node associated with the controller that has been successfully queried){]}     Sent when a nodes values and attributes have been fully queried. At the time this notification is sent, the nodes information has been fully read at least once.  So this notification might trigger full display of the nodes information, values, etc. If this notification is not sent, it indicates that there has been a problem initializing the device.  The most common issue is that the node is a sleeping device.  The NodeQueriesComplete notification will be sent when the node wakes up and the query process completes.

Initialization Complete Notifications

As indicated above, when OpenZWave starts it reads certain information
from a file, from the controller and from the network.  The following
notifications identify when this initialization/querying process is complete.
\begin{itemize}
\item {} 
AwakeNodesQueried

\end{itemize}

{[}always sent{]}   Sent when all listening -always-on-devices have been
queried successfully.  It also indicates, by implication, that there
are some sleeping nodes that will not complete their queries until
they wake up. This notification should be sent relatively quickly
after start-up. (Of course, it depends on the number of devices on
the ZWave network and whether there are any messages that time out
without a proper response.)
\begin{itemize}
\item {} 
AllNodesQueried

\end{itemize}

{[}potentially sent{]}  Sent when all nodes have been successfully queried.

This notification should be sent relatively quickly if there are
no sleeping nodes. But it might be sent quite a while after start-up
if there are sleeping nodes and at least one of these nodes has a long wake-up interval.

Other Notifications

In addition to the notifications described above, which are primarily
initialization notifications that are sent during program start-up,
the following notifications may be sent as a result of user actions,
external program control, etc.
\begin{itemize}
\item {} 
ValueChanged  Sent when a value associated with a node has changed. Receipt of this notification indicates that it may be a good time to read the new value and display or otherwise process it accordingly.

\item {} 
ValueRemoved  Sent when a value associated with a node has been removed.

\item {} 
Group     Sent when a nodes group association has changed.

\item {} 
NodeRemoved   Sent when a node has been removed from the ZWave network.

\item {} 
NodeEvent     Sent when a node sends a Basic\_Set command to the controller.  This notification can be generated by certain sensors, for example, motion detectors, to indicate that an event has been sensed.

\item {} 
PollingEnabled    Sent when node/value polling has been enabled.

\item {} 
PollingDisabled   Sent when node/value polling has been disabled.

\item {} 
DriverReset   Sent to indicate when a controller has been reset.  This notification is intended to replace the potentially hundreds of notifications representing each value and node removed from the network.

\end{itemize}

About the use of louie signals :
For network :
\begin{quote}
\begin{description}
\item[{python-openzwave send the following louie signal :}] \leavevmode
SIGNAL\_NETWORK\_FAILED : the driver has failed to start.
SIGNAL\_NETWORK\_STARTED : the driver is ready, but network is not available.
SIGNAL\_NETWORK\_AWAKED : all awake nodes are queried. Some sleeping nodes may be missing.
SIGNAL\_NETWORK\_READY : all nodes are queried. Network is fully functionnal.
SIGNAL\_NETWORK\_RESETTED : the network has been resetted. It will start again.
SIGNAL\_NETWORK\_STOPPED : the network has been stopped.

\end{description}
\end{quote}

Deprecated : SIGNAL\_DRIVER\_* shouldn't be used anymore.
\index{controller (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.controller}\pysigline{\bfcode{controller}}
The controller of the network.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The controller of the network

\item[{Return type}] \leavevmode
ZWaveController

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_scene() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.create_scene}\pysiglinewithargsret{\bfcode{create\_scene}}{\emph{label=None}}{}
Create a new scene on the network.
If label is set, also change the label of the scene

If you store your scenes on a local variable, get a new one
to get the scene id
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{label} (\emph{str or None}) -- The new label

\item[{Returns}] \leavevmode
return the id of scene on the network. Return 0 if fails

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_poll\_interval() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.get_poll_interval}\pysiglinewithargsret{\bfcode{get\_poll\_interval}}{}{}
Get the time period between polls of a nodes state
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The number of milliseconds between polls

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_scenes() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.get_scenes}\pysiglinewithargsret{\bfcode{get\_scenes}}{}{}
The scenes of the network.

Scenes are generated directly from the lib. There is no notification
support to keep them up to date. So for a batch job, consider
storing them in a local variable.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
return a dict() (that can be empty) of scene object. Return None if betwork is not ready

\item[{Return type}] \leavevmode
dict() or None

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_value() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.get_value}\pysiglinewithargsret{\bfcode{get\_value}}{\emph{value\_id}}{}
Retrieve a value on the network.

Check every nodes to see if it holds the value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The id of the value to find

\item[{Returns}] \leavevmode
The value or None

\item[{Return type}] \leavevmode
ZWaveValue

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_value\_from\_id\_on\_network() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.get_value_from_id_on_network}\pysiglinewithargsret{\bfcode{get\_value\_from\_id\_on\_network}}{\emph{id\_on\_network}}{}
Retrieve a value on the network from it's id\_on\_network.

Check every nodes to see if it holds the value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{id\_on\_network} (\emph{str}) -- The id\_on\_network of the value to find

\item[{Returns}] \leavevmode
The value or None

\item[{Return type}] \leavevmode
ZWaveValue

\end{description}\end{quote}

\end{fulllineitems}

\index{home\_id (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.home_id}\pysigline{\bfcode{home\_id}}
The home\_id of the network.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{home\_id\_str (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.home_id_str}\pysigline{\bfcode{home\_id\_str}}
The home\_id of the network as string.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{id\_separator (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.id_separator}\pysigline{\bfcode{id\_separator}}
The separator in id representation.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
char

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_ready (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.is_ready}\pysigline{\bfcode{is\_ready}}
Says if the network is ready for operations.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{manager (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.manager}\pysigline{\bfcode{manager}}
The manager to use to communicate with the lib c++.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
ZWaveManager

\end{description}\end{quote}

\end{fulllineitems}

\index{nodes (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.nodes}\pysigline{\bfcode{nodes}}
The nodes of the network.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{nodes\_count (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.nodes_count}\pysigline{\bfcode{nodes\_count}}
The nodes count of the network.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_scene() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.remove_scene}\pysiglinewithargsret{\bfcode{remove\_scene}}{\emph{scene\_id}}{}
Delete the scene on the network.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{scene\_id} (\emph{int}) -- The id of the scene to check

\item[{Returns}] \leavevmode
True if the scene was removed. False in other cases

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{scene\_exists() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.scene_exists}\pysiglinewithargsret{\bfcode{scene\_exists}}{\emph{scene\_id}}{}
Check that the scene exists
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{scene\_id} (\emph{int}) -- The id of the scene to check

\item[{Returns}] \leavevmode
True if the scene exist. False in other cases

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{scenes\_count (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.scenes_count}\pysigline{\bfcode{scenes\_count}}
Return the number of scenes
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The number of scenes

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_poll\_interval() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.set_poll_interval}\pysiglinewithargsret{\bfcode{set\_poll\_interval}}{\emph{milliseconds}, \emph{bIntervalBetweenPolls}}{}
Set the time period between polls of a nodes state.

Due to patent concerns, some devices do not report state changes automatically
to the controller.  These devices need to have their state polled at regular
intervals.  The length of the interval is the same for all devices.  To even
out the Z-Wave network traffic generated by polling, OpenZWave divides the
polling interval by the number of devices that have polling enabled, and polls
each in turn.  It is recommended that if possible, the interval should not be
set shorter than the number of polled devices in seconds (so that the network
does not have to cope with more than one poll per second).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{milliseconds} (\emph{int}) -- The length of the polling interval in milliseconds.

\item {} 
\textbf{bIntervalBetweenPolls} (\emph{bool}) -- Don't know what it is.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{sleeping\_nodes\_count (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.sleeping_nodes_count}\pysigline{\bfcode{sleeping\_nodes\_count}}
The count of sleeping nodes on the network.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{start() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.start}\pysiglinewithargsret{\bfcode{start}}{}{}~\begin{description}
\item[{Start the network object :}] \leavevmode\begin{itemize}
\item {} 
add a watcher

\item {} 
add a driver

\end{itemize}

\end{description}

\end{fulllineitems}

\index{state (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.state}\pysigline{\bfcode{state}}
The state of the network. Values may be changed in the future,
only order is important.
You can safely ask node information when state \textgreater{}= STATE\_READY
\begin{itemize}
\item {} 
STATE\_STOPPED = 0

\item {} 
STATE\_FAILED = 1

\item {} 
STATE\_RESETTED = 3

\item {} 
STATE\_STARTED = 5

\item {} 
STATE\_AWAKED = 7

\item {} 
STATE\_READY = 10

\end{itemize}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{state\_str (openzwave.network.ZWaveNetwork attribute)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.state_str}\pysigline{\bfcode{state\_str}}
The state of the network. Values may be changed in the future,
only order is important.
You can safely ask node informations when state \textgreater{}= STATE\_AWAKED
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{stop() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.stop}\pysiglinewithargsret{\bfcode{stop}}{\emph{fire=True}}{}~\begin{description}
\item[{Stop the network object.}] \leavevmode\begin{itemize}
\item {} 
remove the watcher

\item {} 
remove the driver

\item {} 
clear the nodes

\end{itemize}

\end{description}

dispatcher.send(self.SIGNAL\_NETWORK\_STOPPED, {\color{red}\bfseries{}**}\{`network': self\})

\end{fulllineitems}

\index{switch\_all() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.switch_all}\pysiglinewithargsret{\bfcode{switch\_all}}{\emph{state}}{}
Method for switching all devices on or off together.  The devices must support
the SwitchAll command class.  The command is first broadcast to all nodes, and
then followed up with individual commands to each node (because broadcasts are
not routed, the message might not otherwise reach all the nodes).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{state} (\emph{bool}) -- True to turn on the switches, False to turn them off

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.test}\pysiglinewithargsret{\bfcode{test}}{\emph{count=1}}{}
Send a number of test messages to every node and record results.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{count} (\emph{int}) -- The number of test messages to send.

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_config() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.write_config}\pysiglinewithargsret{\bfcode{write\_config}}{}{}
The last message that was sent is now complete.

\end{fulllineitems}

\index{zwcallback() (openzwave.network.ZWaveNetwork method)}

\begin{fulllineitems}
\phantomsection\label{network:openzwave.network.ZWaveNetwork.zwcallback}\pysiglinewithargsret{\bfcode{zwcallback}}{\emph{args}}{}
The Callback Handler used with the libopenzwave.

n{[}'valueId'{]} = \{
\begin{itemize}
\item {} 
`home\_id' : v.GetHomeId(),

\item {} 
`node\_id' : v.GetNodeId(),

\item {} 
`commandClass' : PyManager.COMMAND\_CLASS\_DESC{[}v.GetCommandClassId(){]},

\item {} 
`instance' : v.GetInstance(),

\item {} 
`index' : v.GetIndex(),

\item {} 
`id' : v.GetId(),

\item {} 
`genre' : PyGenres{[}v.GetGenre(){]},

\item {} 
`type' : PyValueTypes{[}v.GetType(){]},

\item {} 
\#'value' : value.c\_str(),

\item {} 
`value' : getValueFromType(manager,v.GetId()),

\item {} 
`label' : label.c\_str(),

\item {} 
`units' : units.c\_str(),

\item {} 
`readOnly': manager.IsValueReadOnly(v)

\end{itemize}

\}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{args} (\emph{dict()}) -- A dict containing informations about the state of the controller

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Controller documentation}
\label{controller:controller-documentation}\label{controller::doc}
The controller is the node of your adaptater. You can use it to retrieve
informations on it : library, statistics, ...
\phantomsection\label{controller:module-openzwave.controller}\index{openzwave.controller (module)}\phantomsection\label{controller:module-openzwave.controller}\index{openzwave.controller (module)}\phantomsection\label{controller:openzwavecontroller}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave API

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveController (class in openzwave.controller)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController}\pysiglinewithargsret{\strong{class }\code{openzwave.controller.}\bfcode{ZWaveController}}{\emph{controller\_id}, \emph{network}, \emph{options=None}}{}
The controller manager.

Allows to retrieve informations about the library, statistics, ...
Also used to send commands to the controller

Commands :
\begin{quote}
\begin{itemize}
\item {} 
Driver::ControllerCommand\_AddController - Add a new secondary controller to the Z-Wave network.

\item {} 
Driver::ControllerCommand\_AddDevice - Add a new device (but not a controller) to the Z-Wave network.

\item {} 
Driver::ControllerCommand\_CreateNewPrimary (Not yet implemented)

\item {} 
Driver::ControllerCommand\_ReceiveConfiguration -

\item {} 
Driver::ControllerCommand\_RemoveController - remove a controller from the Z-Wave network.

\item {} 
Driver::ControllerCommand\_RemoveDevice - remove a device (but not a controller) from the Z-Wave network.

\item {} 
Driver::ControllerCommand\_RemoveFailedNode - move a node to the controller's list of failed nodes.  The node must actually

\end{itemize}

have failed or have been disabled since the command will fail if it responds.  A node must be in the controller's failed nodes list
for ControllerCommand\_ReplaceFailedNode to work.
- Driver::ControllerCommand\_HasNodeFailed - Check whether a node is in the controller's failed nodes list.
- Driver::ControllerCommand\_ReplaceFailedNode - replace a failed device with another. If the node is not in
the controller's failed nodes list, or the node responds, this command will fail.
- Driver:: ControllerCommand\_TransferPrimaryRole    (Not yet implemented) - Add a new controller to the network and
make it the primary.  The existing primary will become a secondary controller.
- Driver::ControllerCommand\_RequestNetworkUpdate - Update the controller with network information from the SUC/SIS.
- Driver::ControllerCommand\_RequestNodeNeighborUpdate - Get a node to rebuild its neighbour list.  This method also does ControllerCommand\_RequestNodeNeighbors afterwards.
- Driver::ControllerCommand\_AssignReturnRoute - Assign a network return route to a device.
- Driver::ControllerCommand\_DeleteAllReturnRoutes - Delete all network return routes from a device.
- Driver::ControllerCommand\_CreateButton - Create a handheld button id.
- Driver::ControllerCommand\_DeleteButton - Delete a handheld button id.
\end{quote}

Callbacks :
\begin{quote}
\begin{itemize}
\item {} 
Driver::ControllerState\_Waiting, the controller is waiting for a user action.  A notice should be displayed

\end{itemize}

to the user at this point, telling them what to do next.
For the add, remove, replace and transfer primary role commands, the user needs to be told to press the
inclusion button on the device that  is going to be added or removed.  For ControllerCommand\_ReceiveConfiguration,
they must set their other controller to send its data, and for ControllerCommand\_CreateNewPrimary, set the other
controller to learn new data.
- Driver::ControllerState\_InProgress - the controller is in the process of adding or removing the chosen node.  It is now too late to cancel the command.
- Driver::ControllerState\_Complete - the controller has finished adding or removing the node, and the command is complete.
- Driver::ControllerState\_Failed - will be sent if the command fails for any reason.
\end{quote}
\index{begin\_command\_add\_device() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_add_device}\pysiglinewithargsret{\bfcode{begin\_command\_add\_device}}{\emph{high\_power=False}}{}
Add a new device to the Z-Wave network.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{high\_power} -- Used only with the AddDevice, AddController, RemoveDevice and RemoveController commands.

\end{description}\end{quote}

Usually when adding or removing devices, the controller operates at low power so that the controller must
be physically close to the device for security reasons.  If \_highPower is true, the controller will
operate at normal power levels instead.  Defaults to false.
:type high\_power: bool
:return: True if the command was accepted and has started.
:rtype: bool

\end{fulllineitems}

\index{begin\_command\_assign\_return\_route() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_assign_return_route}\pysiglinewithargsret{\bfcode{begin\_command\_assign\_return\_route}}{\emph{from\_node\_id}, \emph{to\_node\_id}}{}
Assign a network return route from a node to another one.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{from\_node\_id} (\emph{int}) -- The node that we will use the route.

\item {} 
\textbf{to\_node\_id} (\emph{int}) -- The node that we will change the route

\end{itemize}

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_create\_button() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_create_button}\pysiglinewithargsret{\bfcode{begin\_command\_create\_button}}{\emph{node\_id}, \emph{arg=0}}{}
Create a handheld button id
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{node\_id} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item {} 
\textbf{arg} (\emph{int}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_create\_new\_primary() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_create_new_primary}\pysiglinewithargsret{\bfcode{begin\_command\_create\_new\_primary}}{}{}
Add a new controller to the Z-Wave network. Used when old primary fails. Requires SUC.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_delete\_all\_return\_routes() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_delete_all_return_routes}\pysiglinewithargsret{\bfcode{begin\_command\_delete\_all\_return\_routes}}{\emph{node\_id}}{}
Delete all network return routes from a device.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{node\_id} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_delete\_button() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_delete_button}\pysiglinewithargsret{\bfcode{begin\_command\_delete\_button}}{\emph{node\_id}, \emph{arg=0}}{}
Delete a handheld button id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{node\_id} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item {} 
\textbf{arg} (\emph{int}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_has\_node\_failed() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_has_node_failed}\pysiglinewithargsret{\bfcode{begin\_command\_has\_node\_failed}}{\emph{node\_id}}{}
Check whether a node is in the controller's failed nodes list.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{node\_id} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_receive\_configuration() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_receive_configuration}\pysiglinewithargsret{\bfcode{begin\_command\_receive\_configuration}}{}{}~\begin{itemize}
\item {} 
\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_remove\_device() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_remove_device}\pysiglinewithargsret{\bfcode{begin\_command\_remove\_device}}{\emph{high\_power=False}}{}
Remove a device from the Z-Wave network.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{high\_power} -- Used only with the AddDevice, AddController, RemoveDevice and RemoveController commands.

\end{description}\end{quote}

Usually when adding or removing devices, the controller operates at low power so that the controller must
be physically close to the device for security reasons.  If \_highPower is true, the controller will
operate at normal power levels instead.  Defaults to false.
:type high\_power: bool
:return: True if the command was accepted and has started.
:rtype: bool

\end{fulllineitems}

\index{begin\_command\_remove\_failed\_node() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_remove_failed_node}\pysiglinewithargsret{\bfcode{begin\_command\_remove\_failed\_node}}{\emph{node\_id}}{}
Move a node to the controller's list of failed nodes.  The node must
actually have failed or have been disabled since the command
will fail if it responds.  A node must be in the controller's
failed nodes list for ControllerCommand\_ReplaceFailedNode to work.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{node\_id} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_replace\_failed\_node() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_replace_failed_node}\pysiglinewithargsret{\bfcode{begin\_command\_replace\_failed\_node}}{\emph{node\_id}}{}
Replace a failed device with another. If the node is not in
the controller's failed nodes list, or the node responds, this command will fail.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{node\_id} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_replication\_send() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_replication_send}\pysiglinewithargsret{\bfcode{begin\_command\_replication\_send}}{\emph{high\_power=False}}{}
Send information from primary to secondary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{high\_power} -- Usually when adding or removing devices, the controller operates at low power so that the controller must

\end{description}\end{quote}

be physically close to the device for security reasons.  If \_highPower is true, the controller will
operate at normal power levels instead.  Defaults to false.
:type high\_power: bool
:return: True if the command was accepted and has started.
:rtype: bool

\end{fulllineitems}

\index{begin\_command\_request\_network\_update() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_request_network_update}\pysiglinewithargsret{\bfcode{begin\_command\_request\_network\_update}}{}{}
Update the controller with network information from the SUC/SIS.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_request\_node\_neigbhor\_update() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_request_node_neigbhor_update}\pysiglinewithargsret{\bfcode{begin\_command\_request\_node\_neigbhor\_update}}{\emph{node\_id}}{}
Get a node to rebuild its neighbors list.
This method also does ControllerCommand\_RequestNodeNeighbors afterwards.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{node\_id} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_send\_node\_information() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_send_node_information}\pysiglinewithargsret{\bfcode{begin\_command\_send\_node\_information}}{\emph{node\_id}}{}
Send a node information frame.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{node\_id} (\emph{int}) -- Used only with the ReplaceFailedNode command, to specify the node that is going to be replaced.

\item[{Returns}] \leavevmode
True if the command was accepted and has started.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{begin\_command\_transfer\_primary\_role() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.begin_command_transfer_primary_role}\pysiglinewithargsret{\bfcode{begin\_command\_transfer\_primary\_role}}{\emph{high\_power=False}}{}
Make a different controller the primary.
The existing primary will become a secondary controller.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{high\_power} -- Used only with the AddDevice, AddController, RemoveDevice and RemoveController commands.

\end{description}\end{quote}

Usually when adding or removing devices, the controller operates at low power so that the controller must
be physically close to the device for security reasons.  If \_highPower is true, the controller will
operate at normal power levels instead.  Defaults to false.
:type high\_power: bool
:return: True if the command was accepted and has started.
:rtype: bool

\end{fulllineitems}

\index{cancel\_command() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.cancel_command}\pysiglinewithargsret{\bfcode{cancel\_command}}{}{}
Cancels any in-progress command running on a controller.

\end{fulllineitems}

\index{capabilities (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.capabilities}\pysigline{\bfcode{capabilities}}
The capabilities of the controller.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The capabilities of the controller

\item[{Return type}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{device (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.device}\pysigline{\bfcode{device}}
The device path.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The device (ie /dev/zwave)

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_stats\_label() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.get_stats_label}\pysiglinewithargsret{\bfcode{get\_stats\_label}}{\emph{stat}}{}
Retrieve abel of the statistic from driver.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{stat} -- The code of the stat label to retrieve.

\item[{Returns}] \leavevmode
The label or the stat.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{hard\_reset() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.hard_reset}\pysiglinewithargsret{\bfcode{hard\_reset}}{}{}
Hard Reset a PC Z-Wave Controller.
Resets a controller and erases its network configuration settings.  The
controller becomes a primary controller ready to add devices to a new network.

This command fires a lot of louie signals.
Louie's clients must disconnect from nodes and values signals

dispatcher.send(self.\_network.SIGNAL\_NETWORK\_RESETTED, {\color{red}\bfseries{}**}\{`network': self.\_network\})

\end{fulllineitems}

\index{is\_bridge\_controller (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.is_bridge_controller}\pysigline{\bfcode{is\_bridge\_controller}}
Is this controller using the bridge controller library.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_primary\_controller (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.is_primary_controller}\pysigline{\bfcode{is\_primary\_controller}}
Is this node a primary controller of the network.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_static\_update\_controller (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.is_static_update_controller}\pysigline{\bfcode{is\_static\_update\_controller}}
Is this controller a static update controller (SUC).
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{library\_config\_path (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.library_config_path}\pysigline{\bfcode{library\_config\_path}}
The library Config path.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The library config directory

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{library\_description (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.library_description}\pysigline{\bfcode{library\_description}}
The description of the library.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The library description (name and version)

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{library\_type\_name (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.library_type_name}\pysigline{\bfcode{library\_type\_name}}
The name of the library.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The cpp library name

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{library\_user\_path (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.library_user_path}\pysigline{\bfcode{library\_user\_path}}
The library User path.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The user directory to store user configuration

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{library\_version (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.library_version}\pysigline{\bfcode{library\_version}}
The version of the library.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The cpp library version

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{name (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.name}\pysigline{\bfcode{name}}
The node name of the controller on the network.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The node's name of the controller on the network

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{node (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.node}\pysigline{\bfcode{node}}
The node controller on the network.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The node controller on the network

\item[{Return type}] \leavevmode
ZWaveNode

\end{description}\end{quote}

\end{fulllineitems}

\index{node\_id (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.node_id}\pysigline{\bfcode{node\_id}}
The node Id of the controller on the network.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The node id of the controller on the network

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{options (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.options}\pysigline{\bfcode{options}}
The starting options of the manager.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The options used to start the manager

\item[{Return type}] \leavevmode
ZWaveOption

\end{description}\end{quote}

\end{fulllineitems}

\index{ozw\_library\_version (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.ozw_library_version}\pysigline{\bfcode{ozw\_library\_version}}
The version of the openzwave library.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The openzwave library version

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{python\_library\_version (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.python_library_version}\pysigline{\bfcode{python\_library\_version}}
The version of the python library.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The python library version

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_queue\_count (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.send_queue_count}\pysigline{\bfcode{send\_queue\_count}}
Get count of messages in the outgoing send queue.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Thr count of messages in the outgoing send queue.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{soft\_reset() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.soft_reset}\pysiglinewithargsret{\bfcode{soft\_reset}}{}{}
Soft Reset a PC Z-Wave Controller.
Resets a controller without erasing its network configuration settings.

\end{fulllineitems}

\index{stats (openzwave.controller.ZWaveController attribute)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.stats}\pysigline{\bfcode{stats}}
Retrieve statistics from driver.

Statistics:
\begin{itemize}
\item {} 
s\_SOFCnt                         : Number of SOF bytes received

\item {} 
s\_ACKWaiting                     : Number of unsolicited messages while waiting for an ACK

\item {} 
s\_readAborts                     : Number of times read were aborted due to timeouts

\item {} 
s\_badChecksum                    : Number of bad checksums

\item {} 
s\_readCnt                        : Number of messages successfully read

\item {} 
s\_writeCnt                       : Number of messages successfully sent

\item {} 
s\_CANCnt                         : Number of CAN bytes received

\item {} 
s\_NAKCnt                         : Number of NAK bytes received

\item {} 
s\_ACKCnt                         : Number of ACK bytes received

\item {} 
s\_OOFCnt                         : Number of bytes out of framing

\item {} 
s\_dropped                        : Number of messages dropped \& not delivered

\item {} 
s\_retries                        : Number of messages retransmitted

\item {} 
s\_controllerReadCnt              : Number of controller messages read

\item {} 
s\_controllerWriteCnt             : Number of controller messages sent

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Statistics of the controller

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{zwcallback() (openzwave.controller.ZWaveController method)}

\begin{fulllineitems}
\phantomsection\label{controller:openzwave.controller.ZWaveController.zwcallback}\pysiglinewithargsret{\bfcode{zwcallback}}{\emph{args}}{}
The Callback Handler used when sendig commands to the controller.
Dispatch a louie message.

To do : add node in signal when necessary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{args} (\emph{dict()}) -- A dict containing informations about the state of the controller

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Option documentation}
\label{option::doc}\label{option:option-documentation}
The options to start the manager. You can change the loglvel,...
\phantomsection\label{option:module-openzwave.option}\index{openzwave.option (module)}\phantomsection\label{option:module-openzwave.option}\index{openzwave.option (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave API

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveOption (class in openzwave.option)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption}\pysiglinewithargsret{\strong{class }\code{openzwave.option.}\bfcode{ZWaveOption}}{\emph{device=None}, \emph{config\_path=None}, \emph{user\_path='.'}, \emph{cmd\_line='`}}{}
Represents a Zwave option used to start the manager.
\index{config\_path (openzwave.option.ZWaveOption attribute)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.config_path}\pysigline{\bfcode{config\_path}}
The config path.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{device (openzwave.option.ZWaveOption attribute)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.device}\pysigline{\bfcode{device}}
The device used by the controller.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_append\_log\_file() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_append_log_file}\pysiglinewithargsret{\bfcode{set\_append\_log\_file}}{\emph{status}}{}
Append new session logs to existing log file (false = overwrite).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{status} (\emph{bool}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_associate() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_associate}\pysiglinewithargsret{\bfcode{set\_associate}}{\emph{status}}{}
Enable automatic association of the controller with group one of every device.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{status} (\emph{bool}) -- True to enable logs, False to disable

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_console\_output() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_console_output}\pysiglinewithargsret{\bfcode{set\_console\_output}}{\emph{status}}{}
Display log information on console (as well as save to disk).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{status} (\emph{bool}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_driver\_max\_attempts() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_driver_max_attempts}\pysiglinewithargsret{\bfcode{set\_driver\_max\_attempts}}{\emph{attempts}}{}
Set the driver max attempts before raising an error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{attempts} (\emph{int}) -- Number of attempts

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_dump\_trigger\_level() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_dump_trigger_level}\pysiglinewithargsret{\bfcode{set\_dump\_trigger\_level}}{\emph{level}}{}
Default is to never dump RAM-stored log messages.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{level} -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_exclude() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_exclude}\pysiglinewithargsret{\bfcode{set\_exclude}}{\emph{commandClass}}{}
Remove support for the seted command classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{commandClass} (\emph{str}) -- The command class to exclude

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_include() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_include}\pysiglinewithargsret{\bfcode{set\_include}}{\emph{commandClass}}{}
Only handle the specified command classes.  The Exclude option is ignored if anything is seted here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{commandClass} (\emph{str}) -- The location of the log file

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_interface() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_interface}\pysiglinewithargsret{\bfcode{set\_interface}}{\emph{port}}{}
Identify the serial port to be accessed (TODO: change the code so more than one serial port can be specified and HID).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{port} (\emph{str}) -- The serial port

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_interval\_between\_polls() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_interval_between_polls}\pysiglinewithargsret{\bfcode{set\_interval\_between\_polls}}{\emph{status}}{}
Notifications when transaction complete is reported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{status} (\emph{bool}) -- if false, try to execute the entire poll set within the PollInterval time frame. If true, wait for PollInterval milliseconds between polls

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_log\_file() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_log_file}\pysiglinewithargsret{\bfcode{set\_log\_file}}{\emph{logfile}}{}
Set the log file location.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{logfile} (\emph{str}) -- The location of the log file

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_logging() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_logging}\pysiglinewithargsret{\bfcode{set\_logging}}{\emph{status}}{}
Set the status of logging.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{status} (\emph{bool}) -- True to activate logs, False to disable

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_notify\_transactions() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_notify_transactions}\pysiglinewithargsret{\bfcode{set\_notify\_transactions}}{\emph{status}}{}
Notifications when transaction complete is reported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{status} (\emph{bool}) -- True to enable, False to disable

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_poll\_interval() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_poll_interval}\pysiglinewithargsret{\bfcode{set\_poll\_interval}}{\emph{interval}}{}
30 seconds (can easily poll 30 values in this time; \textasciitilde{}120 values is the effective limit for 30 seconds).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{interval} (\emph{int}) -- interval in seconds

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_queue\_log\_level() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_queue_log_level}\pysiglinewithargsret{\bfcode{set\_queue\_log\_level}}{\emph{level}}{}
Save (in RAM) log messages equal to or above LogLevel\_Debug.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{level} -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_save\_configuration() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_save_configuration}\pysiglinewithargsret{\bfcode{set\_save\_configuration}}{\emph{status}}{}
Save the XML configuration upon driver close.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{status} (\emph{bool}) -- True to enable, False to disable

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_save\_log\_level() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_save_log_level}\pysiglinewithargsret{\bfcode{set\_save\_log\_level}}{\emph{level}}{}
Save (to file) log messages equal to or above LogLevel\_Detail.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{level} -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_suppress\_value\_refresh() (openzwave.option.ZWaveOption method)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.set_suppress_value_refresh}\pysiglinewithargsret{\bfcode{set\_suppress\_value\_refresh}}{\emph{status}}{}
if true, notifications for refreshed (but unchanged) values will not be sent.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{status} (\emph{bool}) -- True to enable, False to disable

\end{description}\end{quote}

\end{fulllineitems}

\index{user\_path (openzwave.option.ZWaveOption attribute)}

\begin{fulllineitems}
\phantomsection\label{option:openzwave.option.ZWaveOption.user_path}\pysigline{\bfcode{user\_path}}
The config path.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Node documentation}
\label{node::doc}\label{node:node-documentation}
The node.
\phantomsection\label{node:module-openzwave.node}\index{openzwave.node (module)}\phantomsection\label{node:module-openzwave.node}\index{openzwave.node (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave API

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveNode (class in openzwave.node)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode}\pysiglinewithargsret{\strong{class }\code{openzwave.node.}\bfcode{ZWaveNode}}{\emph{node\_id}, \emph{network}}{}
Represents a single Node within the Z-Wave Network.
\index{add\_value() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.add_value}\pysiglinewithargsret{\bfcode{add\_value}}{\emph{value\_id}}{}
Add a value to the node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{value\_id} (\emph{int}) -- The id of the value to add

\item {} 
\textbf{command\_class} (\emph{str}) -- The command\_class of the value

\end{itemize}

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{basic (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.basic}\pysigline{\bfcode{basic}}
The basic type of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{capabilities (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.capabilities}\pysigline{\bfcode{capabilities}}
The capabilities of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
set()

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_value() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.change_value}\pysiglinewithargsret{\bfcode{change\_value}}{\emph{value\_id}}{}
Change a value of the node.
Not implemented
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The id of the value to change

\end{description}\end{quote}

\end{fulllineitems}

\index{command\_classes (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.command_classes}\pysigline{\bfcode{command\_classes}}
The commandClasses of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
set()

\end{description}\end{quote}

\end{fulllineitems}

\index{command\_classes\_as\_string (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.command_classes_as_string}\pysigline{\bfcode{command\_classes\_as\_string}}
Return the command classes of the node as string.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
set()

\end{description}\end{quote}

\end{fulllineitems}

\index{generic (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.generic}\pysigline{\bfcode{generic}}
The generic type of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getNodeQueryStage (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.getNodeQueryStage}\pysigline{\bfcode{getNodeQueryStage}}
Is this node a awake.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_command\_class\_as\_string() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.get_command_class_as_string}\pysiglinewithargsret{\bfcode{get\_command\_class\_as\_string}}{\emph{class\_id}}{}
Return the command class representation as string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{class\_id} (\emph{hexadecimal code}) -- the COMMAND\_CLASS to get string representation

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_command\_class\_genres() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.get_command_class_genres}\pysiglinewithargsret{\bfcode{get\_command\_class\_genres}}{}{}
Return the list of genres of command classes
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
set()

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_values() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.get_values}\pysiglinewithargsret{\bfcode{get\_values}}{\emph{class\_id='All'}, \emph{genre='All'}, \emph{type='All'}, \emph{readonly='All'}, \emph{writeonly='All'}}{}
Retrieve the set of values. You can optionnaly filter for a command class,
a genre and/or a type. You can also filter readonly and writeonly params.

This method always filter the values.
If you wan't to get all the node's values, use self.values instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{class\_id} (\emph{hexadecimal code or string}) -- the COMMAND\_CLASS to get values

\item {} 
\textbf{genre} (\emph{`All' or PyGenres}) -- the genre of value

\item {} 
\textbf{type} (\emph{`All' or PyValueTypes}) -- the type of value

\item {} 
\textbf{readonly} (\emph{`All' or True or False}) -- Is this value readonly

\item {} 
\textbf{writeonly} (\emph{`All' or True or False}) -- Is this value writeonly

\end{itemize}

\item[{Return type}] \leavevmode
set() of Values

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_values\_by\_command\_classes() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.get_values_by_command_classes}\pysiglinewithargsret{\bfcode{get\_values\_by\_command\_classes}}{\emph{genre='All'}, \emph{type='All'}, \emph{readonly='All'}, \emph{writeonly='All'}}{}
Retrieve values in a dict() of dicts(). The dict is indexed on the COMMAND\_CLASS.
This allows to browse values grouped by the COMMAND\_CLASS.You can optionnaly filter for a command class,
a genre and/or a type. You can also filter readonly and writeonly params.

This method always filter the values.
If you wan't to get all the node's values, use the property self.values instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{genre} (\emph{`All' or PyGenres}) -- the genre of value

\item {} 
\textbf{type} (\emph{`All' or PyValueTypes}) -- the type of value

\item {} 
\textbf{readonly} (\emph{`All' or True or False}) -- Is this value readonly

\item {} 
\textbf{writeonly} (\emph{`All' or True or False}) -- Is this value writeonly

\end{itemize}

\item[{Return type}] \leavevmode
dict(command\_class : dict(valueids))

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_values\_for\_command\_class() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.get_values_for_command_class}\pysiglinewithargsret{\bfcode{get\_values\_for\_command\_class}}{\emph{class\_id}}{}
Retrieve the set of values for a command class.
Deprecated
For backward compatibility only.
Use get\_values instead
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{class\_id} (\emph{hexadecimal code or string}) -- the COMMAND\_CLASS to get values

\item[{Return type}] \leavevmode
set() of classId

\end{description}\end{quote}

\end{fulllineitems}

\index{groups (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.groups}\pysigline{\bfcode{groups}}
Get the association groups reported by this node

In Z-Wave, groups are numbered starting from one.  For example, if a call to
GetNumGroups returns 4, the \_groupIdx value to use in calls to GetAssociations
AddAssociation and RemoveAssociation will be a number between 1 and 4.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_command\_class() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.has_command_class}\pysiglinewithargsret{\bfcode{has\_command\_class}}{\emph{class\_id}}{}
Check that this node use this commandClass.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{classId} (\emph{hexadecimal code}) -- the COMMAND\_CLASS to check

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeAwake() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.isNodeAwake}\pysiglinewithargsret{\bfcode{isNodeAwake}}{}{}
Is this node a awake.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeFailed (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.isNodeFailed}\pysigline{\bfcode{isNodeFailed}}
Is this node is presume failed.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{isNodeInfoReceived (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.isNodeInfoReceived}\pysigline{\bfcode{isNodeInfoReceived}}
Get whether the node information has been received. Returns True if the node information has been received yet
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{isReady (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.isReady}\pysigline{\bfcode{isReady}}
Get whether the node is ready to operate (QueryStage Completed).
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_beaming\_device (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.is_beaming_device}\pysigline{\bfcode{is\_beaming\_device}}
Is this node a beaming device.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_frequent\_listening\_device (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.is_frequent_listening_device}\pysigline{\bfcode{is\_frequent\_listening\_device}}
Is this node a frequent listening device.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_listening\_device (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.is_listening_device}\pysigline{\bfcode{is\_listening\_device}}
Is this node a listening device.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_locked (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.is_locked}\pysigline{\bfcode{is\_locked}}
Is this node locked.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_routing\_device (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.is_routing_device}\pysigline{\bfcode{is\_routing\_device}}
Is this node a routing device.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_security\_device (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.is_security_device}\pysigline{\bfcode{is\_security\_device}}
Is this node a security device.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_sleeping (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.is_sleeping}\pysigline{\bfcode{is\_sleeping}}
Is this node sleeping.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{location (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.location}\pysigline{\bfcode{location}}
The location of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{manufacturer\_id (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.manufacturer_id}\pysigline{\bfcode{manufacturer\_id}}
The manufacturer id of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{manufacturer\_name (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.manufacturer_name}\pysigline{\bfcode{manufacturer\_name}}
The manufacturer name of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_baud\_rate (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.max_baud_rate}\pysigline{\bfcode{max\_baud\_rate}}
Get the maximum baud rate of a node

\end{fulllineitems}

\index{name (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.name}\pysigline{\bfcode{name}}
The name of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{neighbors (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.neighbors}\pysigline{\bfcode{neighbors}}
The neighbors of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
set()

\end{description}\end{quote}

\end{fulllineitems}

\index{node\_id (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.node_id}\pysigline{\bfcode{node\_id}}
The id of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{num\_groups (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.num_groups}\pysigline{\bfcode{num\_groups}}
Gets the number of association groups reported by this node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_id (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.product_id}\pysigline{\bfcode{product\_id}}
The product Id of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_name (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.product_name}\pysigline{\bfcode{product\_name}}
The product name of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_type (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.product_type}\pysigline{\bfcode{product\_type}}
The product type of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{refresh\_info() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.refresh_info}\pysiglinewithargsret{\bfcode{refresh\_info}}{}{}
Trigger the fetching of fixed data about a node.

Causes the nodes data to be obtained from the Z-Wave network in the same way
as if it had just been added.  This method would normally be called
automatically by OpenZWave, but if you know that a node has been changed,
calling this method will force a refresh of the data held by the library.  This
can be especially useful for devices that were asleep when the application was
first run.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{refresh\_value() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.refresh_value}\pysiglinewithargsret{\bfcode{refresh\_value}}{\emph{value\_id}}{}
Refresh a value of the node.
Not implemented
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The id of the value to change

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_value() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.remove_value}\pysiglinewithargsret{\bfcode{remove\_value}}{\emph{value\_id}}{}
Change a value of the node. Todo
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The id of the value to change

\item[{Returns}] \leavevmode
The result of the operation

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{request\_all\_config\_params() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.request_all_config_params}\pysiglinewithargsret{\bfcode{request\_all\_config\_params}}{}{}
Request the values of all known configurable parameters from a device.

\end{fulllineitems}

\index{request\_config\_param() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.request_config_param}\pysiglinewithargsret{\bfcode{request\_config\_param}}{\emph{param}}{}
Request the value of a configurable parameter from a device.

Some devices have various parameters that can be configured to control the
device behaviour.  These are not reported by the device over the Z-Wave network
but can usually be found in the devices user manual.  This method requests
the value of a parameter from the device, and then returns immediately,
without waiting for a response.  If the parameter index is valid for this
device, and the device is awake, the value will eventually be reported via a
ValueChanged notification callback.  The ValueID reported in the callback will
have an index set the same as \_param and a command class set to the same value
as returned by a call to Configuration::StaticGetCommandClassId.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{param} -- The param of the node.

\end{description}\end{quote}

\end{fulllineitems}

\index{security (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.security}\pysigline{\bfcode{security}}
The security type of the node.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The security type of the node

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_config\_param() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.set_config_param}\pysiglinewithargsret{\bfcode{set\_config\_param}}{\emph{param}, \emph{value}, \emph{size=2}}{}
Set the value of a configurable parameter in a device.

Some devices have various parameters that can be configured to control the
device behaviour.  These are not reported by the device over the Z-Wave network
but can usually be found in the devices user manual.  This method returns
immediately, without waiting for confirmation from the device that the change
has been made.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{param} -- The param of the node.

\item {} 
\textbf{value} -- The value of the param.

\item {} 
\textbf{size} (\emph{int}) -- Is an optional number of bytes to be sent for the parameter value. Defaults to 2.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_field() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.set_field}\pysiglinewithargsret{\bfcode{set\_field}}{\emph{field}, \emph{value}}{}
A helper to set a writable field : name, location, product\_name, ...
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{field} (\emph{str}) -- The field to set : name, location, product\_name, manufacturer\_name

\item {} 
\textbf{value} (\emph{str}) -- The value to set

\end{itemize}

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{specific (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.specific}\pysigline{\bfcode{specific}}
The specific type of the node.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The specific type of the node

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (openzwave.node.ZWaveNode method)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.test}\pysiglinewithargsret{\bfcode{test}}{\emph{count=1}}{}
Send a number of test messages to every node and record results.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{count} (\emph{int}) -- The number of test messages to send.

\end{description}\end{quote}

\end{fulllineitems}

\index{type (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.type}\pysigline{\bfcode{type}}
Get a human-readable label describing the node
:rtype: str

\end{fulllineitems}

\index{version (openzwave.node.ZWaveNode attribute)}

\begin{fulllineitems}
\phantomsection\label{node:openzwave.node.ZWaveNode.version}\pysigline{\bfcode{version}}
The version of the node.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The version of the node

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Command documentation}
\label{command::doc}\label{command:command-documentation}
The commands to use with nodes.
\phantomsection\label{command:module-openzwave.command}\index{openzwave.command (module)}\phantomsection\label{command:module-openzwave.command}\index{openzwave.command (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave wrapper

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveNodeBasic (class in openzwave.command)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeBasic}\pysigline{\strong{class }\code{openzwave.command.}\bfcode{ZWaveNodeBasic}}
Represents an interface to BasicCommands
I known it's not necessary as they can be included in the node directly.
But it's a good starting point.

What I want to do is provide an automatic mapping system hidding
the mapping classes.

First example, the battery level, it's not a basic command but don't care.
Its command class is 0x80.

A user should write
\begin{quote}

if self.handle\_command\_class(class\_id):
\begin{quote}

ret=command\_Class(...)
\end{quote}
\end{quote}

The classic way to do it is a classic method of registering. But

Another way : using heritage multiple

ZWaveNode(ZWaveObject, ZWaveNodeBasic, ....)
The interface will implement methods
command\_class\_0x80(param1,param2,...)
That's the first thing to do
We also can define a property with a friendly name

handle\_command\_class will do the rest

Another way to do it :
A node can manage actuators (switch, dimmer, ...)
and sensors (temperature, consummation, temperature)

So we need a kind of mechanism to retrieve commands in a user friendly way
Same for sensors.

A good use case is the AN158 Plug-in Meter Appliance Module
We will study the following command classes :
`COMMAND\_CLASS\_SWITCH\_ALL', `COMMAND\_CLASS\_SWITCH\_BINARY',
`COMMAND\_CLASS\_METER',

the associated values are :
\begin{description}
\item[{COMMAND\_CLASS\_SWITCH\_ALL}] \leavevmode{[}\{{]}\begin{description}
\item[{72057594101481476L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `',
`data': `On and Off Enabled',
`min': 0L,
`writeonly': False,
`label': `Switch All',
`readonly': False,
`data\_str': `On and Off Enabled',
`type': `List'\}

\end{description}

\end{description}

\}
\begin{description}
\item[{COMMAND\_CLASS\_SWITCH\_BINARY}] \leavevmode{[}\{{]}\begin{description}
\item[{72057594093060096L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `',
`data': False,
`min': 0L,
`writeonly': False,
`label': `Switch',
`readonly': False,
`data\_str': False,
`type': `Bool'\}

\end{description}

\end{description}

\}
\begin{description}
\item[{COMMAND\_CLASS\_METER}] \leavevmode{[}\{{]}\begin{description}
\item[{72057594093273600L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `',
`data': False,
`min': 0L,
`writeonly': False,
`label': `Exporting',
`readonly': True,
`data\_str': False,
`type': `Bool'\},

\item[{72057594101662232L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `',
`data': `False',
`min': 0L,
`writeonly': True,
`label': `Reset',
`readonly': False,
`data\_str': `False',
`type': `Button'\},

\item[{72057594093273090L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `kWh',
`data': 0.0,
`min': 0L,
`writeonly': False,
`label': `Energy',
`readonly': True,
`data\_str': 0.0,
`type': `Decimal'\},

\item[{72057594093273218L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `W',
`data': 0.0,
`min': 0L,
`writeonly': False,
`label': `Power',
`readonly': True,
`data\_str': 0.0,
`type': `Decimal'\}

\end{description}

\end{description}

\}

Another example from an homePro dimmer (not configured in openzwave):
COMMAND\_CLASS\_SWITCH\_MULTILEVEL : \{
\begin{quote}
\begin{description}
\item[{72057594109853736L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `',
`data': `False',
`min': 0L,
`writeonly': True,
`label': `Dim',
`readonly': False,
`data\_str': `False',
`type': `Button'\},

\item[{72057594109853697L: \{}] \leavevmode
`help': `',
`max': 255L,
`is\_polled': False,
`units': `',
`data': 69,
`min': 0L,
`writeonly': False,
`label': `Level',
`readonly': False,
`data\_str': 69,
`type': `Byte'\},

\item[{72057594118242369L: \{}] \leavevmode
`help': `',
`max': 255L,
`is\_polled': False,
`units': `',
`data': 0,
`min': 0L,
`writeonly': False,
`label': `Start Level',
`readonly': False,
`data\_str': 0,
`type': `Byte'\},

\item[{72057594109853720L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `',
`data': `False',
`min': 0L,
`writeonly': True,
`label': `Bright',
`readonly': False,
`data\_str': `False',
`type': `Button'\},

\item[{72057594118242352L: \{}] \leavevmode
`help': `',
`max': 0L,
`is\_polled': False,
`units': `',
`data': False,
`min': 0L,
`writeonly': False,
`label': `Ignore Start Level',
`readonly': False,
`data\_str': False,
`type': `Bool'\}

\end{description}
\end{quote}

\}

What about the conclusion :
\begin{quote}

The COMMAND\_CLASS\_SWITCH\_ALL is defined with the same label and
use a list as parameter. This should be a configuration parameter.
Don't know what to do for this command class

The COMMAND\_CLASS\_SWITCH\_BINARY use a bool as parameter while
COMMAND\_CLASS\_SWITCH\_MULTILEVEL use 2 buttons : Dim and Bright.
Dim and Bright must be done in 2 steps : set the level and activate
the button.

So we must add one or more lines in the actuators :

Switch : \{setter:self.set\_command\_class\_0xYZ(valueId, new), getter:\}
We must find a way to access the value directly

Bright
Dim

So for the COMMAND\_CLASS\_SWITCH\_BINARY we must define a function called
Switch (=the label of the value). What happen if we have 2 switches
on the node : 2 values I suppose.

COMMAND\_CLASS\_SWITCH\_MULTILEVEL uses 2 commands : 4 when 2 dimmers on the
done ? Don't know but it can.

COMMAND\_CLASS\_METER export many values : 2 of them sends a decimal
and are readonly. They also have a Unit defined ans values are readonly

COMMAND\_CLASS\_METER are used for sensors only. So we would map
every values entries as defined before

Programming :
get\_switches : retrieve the list of switches on the node
is\_switch (label) : says if the value with label=label is a switch
get\_switch (label) : retrieve the value where label=label
\end{quote}
\index{can\_wake\_up() (openzwave.command.ZWaveNodeBasic method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeBasic.can_wake_up}\pysiglinewithargsret{\bfcode{can\_wake\_up}}{}{}
Check if node contain the command class 0x84 (COMMAND\_CLASS\_WAKE\_UP).

Filter rules are :
\begin{quote}

command\_class = 0x84
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the node can wake up

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_battery\_level() (openzwave.command.ZWaveNodeBasic method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeBasic.get_battery_level}\pysiglinewithargsret{\bfcode{get\_battery\_level}}{\emph{value\_id=None}}{}
The battery level of this node.
The command 0x80 (COMMAND\_CLASS\_BATTERY) of this node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The value to retrieve state. If None, retrieve the first value

\item[{Returns}] \leavevmode
The level of this battery

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_battery\_levels() (openzwave.command.ZWaveNodeBasic method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeBasic.get_battery_levels}\pysiglinewithargsret{\bfcode{get\_battery\_levels}}{}{}
The command 0x80 (COMMAND\_CLASS\_BATTERY) of this node.
Retrieve the list of values to consider as batteries.
Filter rules are :
\begin{quote}

command\_class = 0x80
genre = ``User''
type = ``Byte''
readonly = True
writeonly = False
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The list of switches on this node

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_power\_level() (openzwave.command.ZWaveNodeBasic method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeBasic.get_power_level}\pysiglinewithargsret{\bfcode{get\_power\_level}}{\emph{value\_id=None}}{}
The power level of this node.
The command 0x73 (COMMAND\_CLASS\_POWERLEVEL) of this node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The value to retrieve state. If None, retrieve the first value

\item[{Returns}] \leavevmode
The level of this battery

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_power\_levels() (openzwave.command.ZWaveNodeBasic method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeBasic.get_power_levels}\pysiglinewithargsret{\bfcode{get\_power\_levels}}{}{}
The command 0x73 (COMMAND\_CLASS\_POWERLEVEL) of this node.
Retrieve the list of values to consider as power\_levels.
Filter rules are :
\begin{quote}

command\_class = 0x73
genre = ``User''
type = ``Byte''
readonly = True
writeonly = False
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The list of switches on this node

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ZWaveNodeSwitch (class in openzwave.command)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch}\pysigline{\strong{class }\code{openzwave.command.}\bfcode{ZWaveNodeSwitch}}
Represents an interface to switches and dimmers Commands
\index{get\_dimmer\_level() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.get_dimmer_level}\pysiglinewithargsret{\bfcode{get\_dimmer\_level}}{\emph{value\_id}}{}
The command 0x26 (COMMAND\_CLASS\_SWITCH\_MULTILEVEL) of this node.
Get the dimmer level (using value value\_id).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The value to retrieve level

\item[{Returns}] \leavevmode
The level : a value between 0-99

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dimmers() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.get_dimmers}\pysiglinewithargsret{\bfcode{get\_dimmers}}{}{}
The command 0x26 (COMMAND\_CLASS\_SWITCH\_MULTILEVEL) of this node.
Retrieve the list of values to consider as dimmers.
Filter rules are :
\begin{quote}

command\_class = 0x26
genre = ``User''
type = ``Bool''
readonly = False
writeonly = False
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The list of dimmers on this node

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_switch\_all\_item() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.get_switch_all_item}\pysiglinewithargsret{\bfcode{get\_switch\_all\_item}}{\emph{value\_id}}{}
The command 0x27 (COMMAND\_CLASS\_SWITCH\_ALL) of this node.
Return the current value (using value value\_id) of a switch\_all.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The value to retrieve switch\_all value

\item[{Returns}] \leavevmode
The value of the value

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_switch\_all\_items() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.get_switch_all_items}\pysiglinewithargsret{\bfcode{get\_switch\_all\_items}}{\emph{value\_id}}{}
The command 0x27 (COMMAND\_CLASS\_SWITCH\_ALL) of this node.
Return the all the possible values (using value value\_id) of a switch\_all.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The value to retrieve items list

\item[{Returns}] \leavevmode
The value of the value

\item[{Return type}] \leavevmode
set()

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_switch\_all\_state() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.get_switch_all_state}\pysiglinewithargsret{\bfcode{get\_switch\_all\_state}}{\emph{value\_id}}{}
The command 0x27 (COMMAND\_CLASS\_SWITCH\_ALL) of this node.
Return the state (using value value\_id) of a switch or a dimmer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The value to retrieve state

\item[{Returns}] \leavevmode
The state of the value

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_switch\_state() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.get_switch_state}\pysiglinewithargsret{\bfcode{get\_switch\_state}}{\emph{value\_id}}{}
The command 0x25 (COMMAND\_CLASS\_SWITCH\_BINARY) of this node.
Return the state (using value value\_id) of a switch.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The value to retrieve state

\item[{Returns}] \leavevmode
The state of the value

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_switches() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.get_switches}\pysiglinewithargsret{\bfcode{get\_switches}}{}{}
The command 0x25 (COMMAND\_CLASS\_SWITCH\_BINARY) of this node.
Retrieve the list of values to consider as switches.
Filter rules are :
\begin{quote}

command\_class = 0x25
genre = ``User''
type = ``Bool''
readonly = False
writeonly = False
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The list of switches on this node

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_switches\_all() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.get_switches_all}\pysiglinewithargsret{\bfcode{get\_switches\_all}}{}{}
The command 0x27 (COMMAND\_CLASS\_SWITCH\_ALL) of this node.
Retrieve the list of values to consider as switches\_all.
Filter rules are :
\begin{quote}

command\_class = 0x27
genre = ``System''
type = ``List''
readonly = False
writeonly = False
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The list of switches on this node

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_dimmer() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.set_dimmer}\pysiglinewithargsret{\bfcode{set\_dimmer}}{\emph{value\_id}, \emph{value}}{}
The command 0x26 (COMMAND\_CLASS\_SWITCH\_MULTILEVEL) of this node.
Set switch to value (using value value\_id).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{value\_id} (\emph{int}) -- The value to retrieve state

\item {} 
\textbf{value} (\emph{int}) -- The level : a value between 0-99 or 255. 255 set the level to the last value.         0 turn the dimmer off

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_switch() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.set_switch}\pysiglinewithargsret{\bfcode{set\_switch}}{\emph{value\_id}, \emph{value}}{}
The command 0x25 (COMMAND\_CLASS\_SWITCH\_BINARY) of this node.
Set switch to value (using value value\_id).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{value\_id} (\emph{int}) -- The value to retrieve state

\item {} 
\textbf{value} (\emph{bool}) -- True or False

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_switch\_all() (openzwave.command.ZWaveNodeSwitch method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSwitch.set_switch_all}\pysiglinewithargsret{\bfcode{set\_switch\_all}}{\emph{value\_id}, \emph{value}}{}
The command 0x27 (COMMAND\_CLASS\_SWITCH\_ALL) of this node.
Set switches\_all to value (using value value\_id).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{value\_id} (\emph{int}) -- The value to retrieve state

\item {} 
\textbf{value} (\emph{str}) -- A predefined string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ZWaveNodeSensor (class in openzwave.command)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSensor}\pysigline{\strong{class }\code{openzwave.command.}\bfcode{ZWaveNodeSensor}}
Represents an interface to Sensor Commands
\index{get\_sensor\_value() (openzwave.command.ZWaveNodeSensor method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSensor.get_sensor_value}\pysiglinewithargsret{\bfcode{get\_sensor\_value}}{\emph{value\_id}}{}
The command 0x30 (COMMAND\_CLASS\_SENSOR\_BINARY) of this node.
The command 0x31 (COMMAND\_CLASS\_SENSOR\_MULTILEVEL) of this node.
The command 0x32 (COMMAND\_CLASS\_METER) of this node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The value to retrieve value

\item[{Returns}] \leavevmode
The state of the sensors

\item[{Return type}] \leavevmode
variable

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sensors() (openzwave.command.ZWaveNodeSensor method)}

\begin{fulllineitems}
\phantomsection\label{command:openzwave.command.ZWaveNodeSensor.get_sensors}\pysiglinewithargsret{\bfcode{get\_sensors}}{\emph{type='All'}}{}
The command 0x30 (COMMAND\_CLASS\_SENSOR\_BINARY) of this node.
The command 0x31 (COMMAND\_CLASS\_SENSOR\_MULTILEVEL) of this node.
The command 0x32 (COMMAND\_CLASS\_METER) of this node.
Retrieve the list of values to consider as sensors.
Filter rules are :
\begin{quote}

command\_class = 0x30-32
genre = ``User''
readonly = True
writeonly = False
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{type} (\emph{`All' or PyValueTypes}) -- the type of value

\item[{Returns}] \leavevmode
The list of switches on this node

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Group documentation}
\label{group::doc}\label{group:group-documentation}
The group is used in associations.
\phantomsection\label{group:module-openzwave.group}\index{openzwave.group (module)}\phantomsection\label{group:module-openzwave.group}\index{openzwave.group (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave API

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveGroup (class in openzwave.group)}

\begin{fulllineitems}
\phantomsection\label{group:openzwave.group.ZWaveGroup}\pysiglinewithargsret{\strong{class }\code{openzwave.group.}\bfcode{ZWaveGroup}}{\emph{group\_index}, \emph{network=None}, \emph{node\_id=None}}{}
The driver object.
Hold options of the manager
Also used to retrieve information about the library, ...
\index{add\_association() (openzwave.group.ZWaveGroup method)}

\begin{fulllineitems}
\phantomsection\label{group:openzwave.group.ZWaveGroup.add_association}\pysiglinewithargsret{\bfcode{add\_association}}{\emph{target\_node\_id}}{}
Adds a node to an association group.

Due to the possibility of a device being asleep, the command is assumed to
complete with success, and the association data held in this class is updated directly.  This
will be reverted by a future Association message from the device if the Z-Wave
message actually failed to get through.  Notification callbacks will be sent in
both cases.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{target\_node\_id} (\emph{int}) -- Identifier for the node that will be added to the association group.

\end{description}\end{quote}

\end{fulllineitems}

\index{associations (openzwave.group.ZWaveGroup attribute)}

\begin{fulllineitems}
\phantomsection\label{group:openzwave.group.ZWaveGroup.associations}\pysigline{\bfcode{associations}}
The members of associations.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
set()

\end{description}\end{quote}

\end{fulllineitems}

\index{index (openzwave.group.ZWaveGroup attribute)}

\begin{fulllineitems}
\phantomsection\label{group:openzwave.group.ZWaveGroup.index}\pysigline{\bfcode{index}}
The index of the group.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{label (openzwave.group.ZWaveGroup attribute)}

\begin{fulllineitems}
\phantomsection\label{group:openzwave.group.ZWaveGroup.label}\pysigline{\bfcode{label}}
The label of the group.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_associations (openzwave.group.ZWaveGroup attribute)}

\begin{fulllineitems}
\phantomsection\label{group:openzwave.group.ZWaveGroup.max_associations}\pysigline{\bfcode{max\_associations}}
The number of associations.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_association() (openzwave.group.ZWaveGroup method)}

\begin{fulllineitems}
\phantomsection\label{group:openzwave.group.ZWaveGroup.remove_association}\pysiglinewithargsret{\bfcode{remove\_association}}{\emph{target\_node\_id}}{}
Removes a node from an association group.

Due to the possibility of a device being asleep, the command is assumed to
succeed, and the association data held in this class is updated directly.  This
will be reverted by a future Association message from the device if the Z-Wave
message actually failed to get through.   Notification callbacks will be sent
in both cases.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{target\_node\_id} (\emph{int}) -- Identifier for the node that will be removed from the association group.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Value documentation}
\label{value:value-documentation}\label{value::doc}
The value.
\phantomsection\label{value:module-openzwave.value}\index{openzwave.value (module)}\phantomsection\label{value:module-openzwave.value}\index{openzwave.value (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave API

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveValue (class in openzwave.value)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue}\pysiglinewithargsret{\strong{class }\code{openzwave.value.}\bfcode{ZWaveValue}}{\emph{value\_id}, \emph{network=None}, \emph{parent=None}}{}
Represents a single value.
\index{check\_data() (openzwave.value.ZWaveValue method)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.check_data}\pysiglinewithargsret{\bfcode{check\_data}}{\emph{data}}{}
Check that data is correct for this value.
Return the data in a correct type. None is data is incorrect.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data} (\emph{lambda}) -- The data value to check

\item[{Returns}] \leavevmode
A variable of the good type if the data is correct. None otherwise.

\item[{Return type}] \leavevmode
variable

\end{description}\end{quote}

\end{fulllineitems}

\index{command\_class (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.command_class}\pysigline{\bfcode{command\_class}}
The command class of the value.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The command class of this value

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{data (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.data}\pysigline{\bfcode{data}}
Get the current data of the value.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The data of the value

\item[{Return type}] \leavevmode
depending of the type of the value

\end{description}\end{quote}

\end{fulllineitems}

\index{data\_as\_string (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.data_as_string}\pysigline{\bfcode{data\_as\_string}}
Get the value data as String.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{data\_items (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.data_items}\pysigline{\bfcode{data\_items}}
When type of value is list, data\_items contains a list of valid values
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The valid values or a help string

\item[{Return type}] \leavevmode
string or set

\end{description}\end{quote}

\end{fulllineitems}

\index{disable\_poll() (openzwave.value.ZWaveValue method)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.disable_poll}\pysiglinewithargsret{\bfcode{disable\_poll}}{}{}
Disable poll off this value.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if polling was disabled.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{enable\_poll() (openzwave.value.ZWaveValue method)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.enable_poll}\pysiglinewithargsret{\bfcode{enable\_poll}}{\emph{intensity=1}}{}
Enable the polling of a device's state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{intensity} (\emph{int}) -- The intensity of the poll

\item[{Returns}] \leavevmode
True if polling was enabled.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{genre (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.genre}\pysigline{\bfcode{genre}}
Get the genre of the value.  The genre classifies a value to enable
low-level system or configuration parameters to be filtered out
by the application
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
genre of the value (Basic, User, Config, System)

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{help (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.help}\pysigline{\bfcode{help}}
Gets a help string describing the value's purpose and usage.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{id\_on\_network (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.id_on_network}\pysigline{\bfcode{id\_on\_network}}
Get an unique id for this value.

The scenes use this to retrieve values
\textless{}Scene id=''1'' label=''scene1''\textgreater{}
\begin{quote}

\textless{}Value homeId=''0x014d0ef5'' nodeId=''2'' genre=''user'' commandClassId=''38'' instance=''1'' index=''0'' type=''byte''\textgreater{}54\textless{}/Value\textgreater{}
\end{quote}

\textless{}/Scene\textgreater{}
The format is :
\begin{quote}

home\_id.node\_id.command\_class.instance.index
\end{quote}

\end{fulllineitems}

\index{index (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.index}\pysigline{\bfcode{index}}
Get the value index.  The index is used to identify one of multiple
values created and managed by a command class.  In the case of configurable
parameters (handled by the configuration command class), the index is the
same as the parameter ID.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
index of the value

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{instance (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.instance}\pysigline{\bfcode{instance}}
Get the command class instance of this value.  It is possible for there to be
multiple instances of a command class, although currently it appears that
only the SensorMultilevel command class ever does this.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
instance of the value

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_change\_verified() (openzwave.value.ZWaveValue method)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.is_change_verified}\pysiglinewithargsret{\bfcode{is\_change\_verified}}{}{}
determine if value changes upon a refresh should be verified.
If so, the library will immediately refresh the value a second time whenever a change is observed.
This helps to filter out spurious data reported occasionally by some devices.

\end{fulllineitems}

\index{is\_polled (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.is_polled}\pysigline{\bfcode{is\_polled}}
Verify that the value is polled.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_read\_only (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.is_read_only}\pysigline{\bfcode{is\_read\_only}}
Test whether the value is read-only.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the value cannot be changed by the user.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_set (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.is_set}\pysigline{\bfcode{is\_set}}
Test whether the value has been set.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the value has actually been set by a status message

\end{description}\end{quote}

from the device, rather than simply being the default.
:rtype: bool

\end{fulllineitems}

\index{is\_write\_only (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.is_write_only}\pysigline{\bfcode{is\_write\_only}}
Test whether the value is write-only.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the value can only be written to and not read.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{label (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.label}\pysigline{\bfcode{label}}
Get the label of the value.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{max (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.max}\pysigline{\bfcode{max}}
Gets the maximum that this value may contain.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{min (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.min}\pysigline{\bfcode{min}}
Gets the minimum that this value may contain.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{node (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.node}\pysigline{\bfcode{node}}
The value\_id of the value.

\end{fulllineitems}

\index{parent\_id (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.parent_id}\pysigline{\bfcode{parent\_id}}
Get the parent\_id of the value.

\end{fulllineitems}

\index{poll\_intensity (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.poll_intensity}\pysigline{\bfcode{poll\_intensity}}
The poll intensity of the value.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0=none, 1=every time through the list, 2-every other time, etc

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{precision (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.precision}\pysigline{\bfcode{precision}}
Gets a float value's precision.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a float value's precision

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{refresh() (openzwave.value.ZWaveValue method)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.refresh}\pysiglinewithargsret{\bfcode{refresh}}{}{}
Refresh the value.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the command was transmitted to controller

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_change\_verified() (openzwave.value.ZWaveValue method)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.set_change_verified}\pysiglinewithargsret{\bfcode{set\_change\_verified}}{\emph{verify}}{}
Sets a flag indicating whether value changes noted upon a refresh should be verified.

If so, the library will immediately refresh the value a second time whenever a change is observed.
This helps to filter out spurious data reported occasionally by some devices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{verify} (\emph{bool}) -- if true, verify changes; if false, don't verify changes.

\end{description}\end{quote}

\end{fulllineitems}

\index{type (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.type}\pysigline{\bfcode{type}}
Get the type of the value.  The type describes the data held by the value
and enables the user to select the correct value accessor method in the
Manager class.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
type of the value

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{units (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.units}\pysigline{\bfcode{units}}
Gets the units that the value is measured in.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{value\_id (openzwave.value.ZWaveValue attribute)}

\begin{fulllineitems}
\phantomsection\label{value:openzwave.value.ZWaveValue.value_id}\pysigline{\bfcode{value\_id}}
Get the value\_id of the value.

\end{fulllineitems}


\end{fulllineitems}



\section{Scene documentation}
\label{scene:scene-documentation}\label{scene::doc}
The scenes.
\phantomsection\label{scene:module-openzwave.scene}\index{openzwave.scene (module)}\phantomsection\label{scene:module-openzwave.scene}\index{openzwave.scene (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave API

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveScene (class in openzwave.scene)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene}\pysiglinewithargsret{\strong{class }\code{openzwave.scene.}\bfcode{ZWaveScene}}{\emph{scene\_id}, \emph{network=None}}{}
Represents a single scene within the Z-Wave Network
\index{activate() (openzwave.scene.ZWaveScene method)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.activate}\pysiglinewithargsret{\bfcode{activate}}{}{}
Activate the zwave scene.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if the scene is activated. False otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_value() (openzwave.scene.ZWaveScene method)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.add_value}\pysiglinewithargsret{\bfcode{add\_value}}{\emph{value\_id}, \emph{value\_data}}{}
Add a value with data value\_data to the zwave scene.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{value\_id} (\emph{int}) -- The id of the value to add

\item {} 
\textbf{value\_data} (\emph{variable}) -- The data of the value to add

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create() (openzwave.scene.ZWaveScene method)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.create}\pysiglinewithargsret{\bfcode{create}}{\emph{label=None}}{}
Create a new zwave scene on the network and update the object\_id field
If label is set, also change the label of the scene
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{label} (\emph{str or None}) -- The new label

\item[{Returns}] \leavevmode
return the id of scene on the network. Return 0 if fails

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_values() (openzwave.scene.ZWaveScene method)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.get_values}\pysiglinewithargsret{\bfcode{get\_values}}{}{}
Get all the values of the scene
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A dict of values : \{value\_id=\{`value'=ZWaveValue, `data'=data\}, ...\}.

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_values\_by\_node() (openzwave.scene.ZWaveScene method)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.get_values_by_node}\pysiglinewithargsret{\bfcode{get\_values\_by\_node}}{}{}
Get all the values of the scene grouped by nodes
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A dict of values : \{node\_id=\{value\_id=\{`value'=ZWaveValue, `data'=data\}, ...\},...\}.

\item[{Return type}] \leavevmode
dict()

\end{description}\end{quote}

\end{fulllineitems}

\index{label (openzwave.scene.ZWaveScene attribute)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.label}\pysigline{\bfcode{label}}
The label of the scene.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_value() (openzwave.scene.ZWaveScene method)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.remove_value}\pysiglinewithargsret{\bfcode{remove\_value}}{\emph{value\_id}}{}
Remove a value from the scene.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{value\_id} (\emph{int}) -- The id of the value to change

\item[{Returns}] \leavevmode
True if the scene is removed. False otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{scene\_id (openzwave.scene.ZWaveScene attribute)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.scene_id}\pysigline{\bfcode{scene\_id}}
The id of the scene.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_value() (openzwave.scene.ZWaveScene method)}

\begin{fulllineitems}
\phantomsection\label{scene:openzwave.scene.ZWaveScene.set_value}\pysiglinewithargsret{\bfcode{set\_value}}{\emph{value\_id}, \emph{value\_data}}{}
Set a value data to value\_data in the zwave scene.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{value\_id} (\emph{int}) -- The id of the value to add

\item {} 
\textbf{value\_data} (\emph{variable}) -- The data of the value to add

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Object documentation}
\label{object:object-documentation}\label{object::doc}
The low level object. Implements cache mechanism.
\phantomsection\label{object:module-openzwave.object}\index{openzwave.object (module)}\phantomsection\label{object:module-openzwave.object}\index{openzwave.object (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave API

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{ZWaveObject (class in openzwave.object)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject}\pysiglinewithargsret{\strong{class }\code{openzwave.object.}\bfcode{ZWaveObject}}{\emph{object\_id}, \emph{network=None}, \emph{use\_cache=True}}{}
Represents a Zwave object. Values, nodes, ... can be changer by
other managers on the network.
\index{cache\_property() (openzwave.object.ZWaveObject method)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.cache_property}\pysiglinewithargsret{\bfcode{cache\_property}}{\emph{prop}}{}
Add this property to the cache manager.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{prop} (\emph{lambda}) -- The property to cache

\end{description}\end{quote}

\end{fulllineitems}

\index{home\_id (openzwave.object.ZWaveObject attribute)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.home_id}\pysigline{\bfcode{home\_id}}
The home\_id of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_outdated() (openzwave.object.ZWaveObject method)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.is_outdated}\pysiglinewithargsret{\bfcode{is\_outdated}}{\emph{prop}}{}
Check if property information is outdated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{prop} (\emph{lambda}) -- The property to check

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{last\_update (openzwave.object.ZWaveObject attribute)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.last_update}\pysigline{\bfcode{last\_update}}
The last update date of the device.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
time

\end{description}\end{quote}

\end{fulllineitems}

\index{network (openzwave.object.ZWaveObject attribute)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.network}\pysigline{\bfcode{network}}
The network of the node.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
ZWaveNetwork

\end{description}\end{quote}

\end{fulllineitems}

\index{object\_id (openzwave.object.ZWaveObject attribute)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.object_id}\pysigline{\bfcode{object\_id}}
The id of the object.
object\_id could be None, when creating a scene for example.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{outdate() (openzwave.object.ZWaveObject method)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.outdate}\pysiglinewithargsret{\bfcode{outdate}}{\emph{prop}}{}
Says that the property information is outdated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{prop} (\emph{lambda}) -- The property to outdate

\end{description}\end{quote}

\end{fulllineitems}

\index{outdated (openzwave.object.ZWaveObject attribute)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.outdated}\pysigline{\bfcode{outdated}}
Are the information of this object outdated.

How to manage the cache ?

2 ways of doing it :
- refresh information when setting the property
- refresh information when getting getting property.
Maybe whe could implement the 2 methods.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (openzwave.object.ZWaveObject method)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.update}\pysiglinewithargsret{\bfcode{update}}{\emph{prop}}{}
Says that the property are updated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{prop} (\emph{lambda}) -- The property to update

\end{description}\end{quote}

\end{fulllineitems}

\index{use\_cache (openzwave.object.ZWaveObject attribute)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveObject.use_cache}\pysigline{\bfcode{use\_cache}}
Should this object use cache from property
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ZWaveNodeInterface (class in openzwave.object)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveNodeInterface}\pysigline{\strong{class }\code{openzwave.object.}\bfcode{ZWaveNodeInterface}}
Represents an interface of a node. An interface can manage
specific commandClasses (ie a switch, a dimmer, a thermostat, ...).
Don't know what to do with it now but sure it must exist

\end{fulllineitems}

\index{ZWaveException}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveException}\pysiglinewithargsret{\strong{exception }\code{openzwave.object.}\bfcode{ZWaveException}}{\emph{value}}{}
Exception class for OpenZWave

\end{fulllineitems}

\index{ZWaveTypeException}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveTypeException}\pysiglinewithargsret{\strong{exception }\code{openzwave.object.}\bfcode{ZWaveTypeException}}{\emph{value}}{}
Exception class for OpenZWave

\end{fulllineitems}

\index{ZWaveCacheException}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveCacheException}\pysiglinewithargsret{\strong{exception }\code{openzwave.object.}\bfcode{ZWaveCacheException}}{\emph{value}}{}
Exception class for OpenZWave

\end{fulllineitems}

\index{ZWaveCommandClassException}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.ZWaveCommandClassException}\pysiglinewithargsret{\strong{exception }\code{openzwave.object.}\bfcode{ZWaveCommandClassException}}{\emph{value}}{}
Exception class for OpenZWave

\end{fulllineitems}

\index{NullLoggingHandler (class in openzwave.object)}

\begin{fulllineitems}
\phantomsection\label{object:openzwave.object.NullLoggingHandler}\pysiglinewithargsret{\strong{class }\code{openzwave.object.}\bfcode{NullLoggingHandler}}{\emph{level=0}}{}
A Null Logging Handler

\end{fulllineitems}



\section{Data documentation}
\label{data:data-documentation}\label{data::doc}
The common data structures and defitions.
\phantomsection\label{data:module-libopenzwave}\index{libopenzwave (module)}\phantomsection\label{data:module-libopenzwave}\index{libopenzwave (module)}\begin{description}
\item[{This file is part of \textbf{python-openzwave} project \href{http://code.google.com/p/python-openzwave}{http://code.google.com/p/python-openzwave}.}] \leavevmode\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows, MacOS X

\item[{sinopsis}] \leavevmode
openzwave C++

\end{description}\end{quote}

\end{description}

License : GPL(v3)

\textbf{python-openzwave} is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

\textbf{python-openzwave} is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with python-openzwave. If not, see \href{http://www.gnu.org/licenses}{http://www.gnu.org/licenses}.
\index{PyNotifications (in module libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{data:libopenzwave.PyNotifications}\pysigline{\code{libopenzwave.}\bfcode{PyNotifications}\strong{ = {[}'ValueAdded', `ValueRemoved', `ValueChanged', `ValueRefreshed', `Group', `NodeNew', `NodeAdded', `NodeRemoved', `NodeProtocolInfo', `NodeNaming', `NodeEvent', `PollingDisabled', `PollingEnabled', `SceneEvent', `CreateButton', `DeleteButton', `ButtonOn', `ButtonOff', `DriverReady', `DriverFailed', `DriverReset', `EssentialNodeQueriesComplete', `NodeQueriesComplete', `AwakeNodesQueried', `AllNodesQueried', `AllNodesQueriedSomeDead', `Notification', `DriverRemoved'{]}}}
list() -\textgreater{} new empty list
list(iterable) -\textgreater{} new list initialized from iterable's items

\end{fulllineitems}

\index{PyGenres (in module libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{data:libopenzwave.PyGenres}\pysigline{\code{libopenzwave.}\bfcode{PyGenres}\strong{ = {[}'Basic', `User', `Config', `System'{]}}}
list() -\textgreater{} new empty list
list(iterable) -\textgreater{} new list initialized from iterable's items

\end{fulllineitems}

\index{PyValueTypes (in module libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{data:libopenzwave.PyValueTypes}\pysigline{\code{libopenzwave.}\bfcode{PyValueTypes}\strong{ = {[}'Bool', `Byte', `Decimal', `Int', `List', `Schedule', `Short', `String', `Button', `Raw'{]}}}
list() -\textgreater{} new empty list
list(iterable) -\textgreater{} new list initialized from iterable's items

\end{fulllineitems}

\index{PyLogLevels (in module libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{data:libopenzwave.PyLogLevels}\pysigline{\code{libopenzwave.}\bfcode{PyLogLevels}\strong{ = \{`Info': 6, `None': 0, `StreamDetail': 9, `Internal': 10, `Always': 1, `Detail': 7, `Alert': 5, `Warning': 4, `Error': 3, `Debug': 8, `Fatal': 2\}}}
dict() -\textgreater{} new empty dictionary
dict(mapping) -\textgreater{} new dictionary initialized from a mapping object's
\begin{quote}

(key, value) pairs
\end{quote}
\begin{description}
\item[{dict(iterable) -\textgreater{} new dictionary initialized as if via:}] \leavevmode
d = \{\}
for k, v in iterable:
\begin{quote}

d{[}k{]} = v
\end{quote}

\item[{dict({\color{red}\bfseries{}**}kwargs) -\textgreater{} new dictionary initialized with the name=value pairs}] \leavevmode
in the keyword argument list.  For example:  dict(one=1, two=2)

\end{description}

\end{fulllineitems}

\index{PyControllerCommand (in module libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{data:libopenzwave.PyControllerCommand}\pysigline{\code{libopenzwave.}\bfcode{PyControllerCommand}\strong{ = {[}'None', `AddDevice', `CreateNewPrimary', `ReceiveConfiguration', `RemoveDevice', `RemoveFailedNode', `HasNodeFailed', `ReplaceFailedNode', `TransferPrimaryRole', `RequestNetworkUpdate', `RequestNodeNeighborUpdate', `AssignReturnRoute', `DeleteAllReturnRoutes', `SendNodeInformation', `ReplicationSend', `CreateButton', `DeleteButton'{]}}}
list() -\textgreater{} new empty list
list(iterable) -\textgreater{} new list initialized from iterable's items

\end{fulllineitems}

\index{PyControllerState (in module libopenzwave)}

\begin{fulllineitems}
\phantomsection\label{data:libopenzwave.PyControllerState}\pysigline{\code{libopenzwave.}\bfcode{PyControllerState}\strong{ = {[}'Normal', `Starting', `Cancel', `Error', `Waiting', `Sleeping', `InProgress', `Completed', `Failed', `NodeOK', `NodeFailed'{]}}}
list() -\textgreater{} new empty list
list(iterable) -\textgreater{} new list initialized from iterable's items

\end{fulllineitems}



\chapter{Wrapper Documentation}
\label{wrapper:wrapper-documentation}\label{wrapper::doc}
This examples came from the original repository. Don't know if it works
but don't think so. For documentation only.

Contents:


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{l}
\item {\texttt{libopenzwave}}, \pageref{libopenzwave:module-libopenzwave}
\indexspace
\bigletter{o}
\item {\texttt{openzwave.command}}, \pageref{command:module-openzwave.command}
\item {\texttt{openzwave.controller}}, \pageref{controller:module-openzwave.controller}
\item {\texttt{openzwave.group}}, \pageref{group:module-openzwave.group}
\item {\texttt{openzwave.network}}, \pageref{network:module-openzwave.network}
\item {\texttt{openzwave.node}}, \pageref{node:module-openzwave.node}
\item {\texttt{openzwave.object}}, \pageref{object:module-openzwave.object}
\item {\texttt{openzwave.option}}, \pageref{option:module-openzwave.option}
\item {\texttt{openzwave.scene}}, \pageref{scene:module-openzwave.scene}
\item {\texttt{openzwave.value}}, \pageref{value:module-openzwave.value}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
